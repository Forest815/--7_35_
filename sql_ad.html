<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>同時実行制御 解説 - Kazushi's portfolio</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
    <style>
      .code-block{position:relative;padding-top:44px}
      .code-block .exercise-hidden { display: none; }
      .code-toggle-btn{position:absolute;top:8px;right:96px;padding:6px 10px;background:#1976d2;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:700;font-size:0.9rem;z-index:50;white-space:nowrap}
      .copy-btn{
        position:absolute;top:8px;right:8px;padding:6px 8px;background:#444;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:700;font-size:0.9rem;z-index:40;box-sizing:border-box;width:84px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis
      }
      @media (max-width:480px){
        /* on narrow screens, avoid right-edge clipping by swapping positions */
        .code-toggle-btn{right:8px}
        .copy-btn{right:96px}
      }
      .copy-btn:active{transform:translateY(1px)}
      .copy-btn.copied{background:#2e7d32}
      .quiz-answer{display:none;white-space:pre-wrap}
      .quiz-answer.show{display:block}
      .page-toc{margin-top:10px;border-top:1px solid rgba(255,255,255,0.06);padding-top:8px}
      .page-toc a{display:block;padding:6px 0;color:inherit;text-decoration:none}
      .page-toc a:hover{text-decoration:underline}
      .code-explain{margin:8px 0 18px;padding:10px;background:rgba(0,0,0,0.04);border-radius:6px;color:inherit;font-size:0.95rem}
      .result-explain{margin:8px 0 18px;padding:10px;background:rgba(0,0,0,0.03);border-left:3px solid rgba(0,0,0,0.08);border-radius:4px;color:inherit;font-size:0.92rem}
    </style>
  </head>
  <body>
    <div class="menu-icon" onclick="toggleMenu()">
      <span></span>
      <span></span>
      <span></span>
    </div>

    <h1><a href="index.html" style="color: lemonchiffon; text-decoration: none;">Kazushi's portfolio</a></h1>

    <nav class="navigation" id="navigation">
      <ul>
        <li><a href="profile.html" onclick="toggleMenu()">Profile</a></li>
        <li><a href="skills.html" onclick="toggleMenu()">Skills</a></li>
        <li><a href="fes.html" onclick="toggleMenu()">高専祭</a></li>
        <li><a href="works.html" onclick="toggleMenu()">作品</a></li>
        <li><a href="sql.html" onclick="toggleMenu()">SQL解説</a></li>
        <li><a href="sql_ad.html" onclick="toggleMenu()">同時実行制御</a></li>
        <li>
          <div class="page-toc">
            <strong>このページ</strong>
            <a href="#what-is-concurrency" onclick="toggleMenu()">同時実行制御とは何か</a>
            <a href="#intro" onclick="toggleMenu()">導入（銀行口座）</a>
            <a href="#prep" onclick="toggleMenu()">実験準備</a>
            <a href="#exp-a" onclick="toggleMenu()">実験A: READ COMMITTED</a>
            <a href="#exp-b" onclick="toggleMenu()">実験B: ノンリピータブル/ファントム</a>
            <a href="#exp-c" onclick="toggleMenu()">実験C: デッドロック</a>
            <a href="#exercise" onclick="toggleMenu()">演習課題</a>
            <a href="#checks" onclick="toggleMenu()">学習チェックリスト</a>
            <a href="#summary" onclick="toggleMenu()">まとめ</a>
          </div>
        </li>
        <li><a href="procon.html" onclick="toggleMenu()">高専プロコン</a></li>
        
      </ul>
    </nav>

    <h2>同時実行制御</h2>

    <section class="fes-section" id="what-is-concurrency">
      <h3>同時実行制御とは何か</h3>
      <p>同時実行制御は、複数のトランザクションが同時にデータベースへアクセスする際に、データの整合性を保ちつつ効率的に処理を行うための仕組みです。隔離レベル（Isolation）、ロック（Lock）、トランザクションの境界（BEGIN/COMMIT）などを組み合わせて、Dirty Read、Lost Update、Non‑repeatable Read、Phantom Read といった問題を防ぎます。実務では「一貫性」と「スループット（同時実行性）」のトレードオフを理解して、適切な手法を選ぶことが重要です。</p>
      <p>この教材では「実験 → 謎解き → 解説」の流れで、隔離レベルやロック、デッドロックの検出などを実際に体験しながら学びます。</p>
    </section>

    <section class="fes-section" id="intro">
      <h3>導入：嵐の中の銀行口座</h3>
      <p>シナリオ: AさんがBさんへ1000円振り込む処理と、別のセッションで口座残高を確認する処理が同時に走ったらどうなるかを考えます。</p>
      <p>掴み: トランザクションやロックを使わないと、<strong>Lost Update（更新消失）</strong>や計算の矛盾が発生することを簡単なデモで示します。</p>
    </section>

    <section class="fes-section" id="prep">
      <h3>実験準備：2つの世界を用意する</h3>
      <p>ハンズオン手順：</p>
      <ol>
        <li>ターミナルまたはpgAdminを2つ開き、PostgreSQLに接続（セッションA / セッションB）。</li>
        <li>各セッションで自分のPIDを確認して、どちらがA/Bかを識別する。</li>
      </ol>
      <div class="code-block">
        <pre><code class="language-sql">-- 簡単な口座テーブル準備（1回だけ実行）
CREATE TABLE IF NOT EXISTS accounts (
  id SERIAL PRIMARY KEY,
  name TEXT,
  balance INT NOT NULL
);

TRUNCATE TABLE accounts;
INSERT INTO accounts (name, balance) VALUES ('A', 5000), ('B', 3000);

-- 自分のセッションPID確認（psqlの場合）
SELECT pg_backend_pid();
</code></pre>
      </div>
      <div class="quiz-question" onclick="toggleAnswer(this)"><strong>実行結果例（正常動作）を表示</strong></div>
      <div class="quiz-answer"><div class="result-block">
        <pre><code class="language-sql">
    CREATE TABLE
    TRUNCATE TABLE
    INSERT 0 2
     pg_backend_pid 
    ----------------
           1076
    (1 行)</code></pre>
      </div></div>
    </section>

    <section class="fes-section" id="exp-a">
      <h3>実験A：デフォルトの READ COMMITTED を知る</h3>
      <p>流れ：</p>
      <ol>
        <li>セッションA: BEGIN; UPDATE accounts SET balance = balance - 1000 WHERE id = 1; （まだ COMMIT しない）</li>
        <li>セッションB: SELECT balance FROM accounts WHERE id = 1; → 変更前の値が見える（デフォルトではコミット済みの値のみ参照）</li>
        <li>セッションA: COMMIT;</li>
        <li>セッションB: もう一度 SELECT → 変更後の値が見える</li>
      </ol>
      <div class="code-block">
        <pre><code class="language-sql">-- セッションA
BEGIN;
UPDATE accounts SET balance = balance - 1000 WHERE id = 1;

-- セッションB
SELECT balance FROM accounts WHERE id = 1;

-- セッションA続き
COMMIT;

-- セッションB再度
SELECT balance FROM accounts WHERE id = 1;
</code></pre>
      </div>
      <p>解説: PostgreSQL のデフォルト隔離レベルは <strong>READ COMMITTED</strong>。未コミットの変更は他セッションからは見えません。</p>
        <div class="quiz-question" onclick="toggleAnswer(this)"><strong>実行結果例（正常動作）を表示</strong></div>
        <div class="quiz-answer"><div class="result-block">
        <pre><code class="language-sql">
    BEGIN
    UPDATE 1
     balance
    ---------
      4000
    (1 行)

    COMMIT
     balance
    ---------
      4000
    (1 行)</code></pre>
        </div></div>
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. READ COMMITTED の特徴は何か?</div>
      <div class="quiz-answer">各クエリ実行時にコミット済みの最新データを見る。トランザクション中の別セッションの未コミット変更は見えない。</div>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. Lost Update を防ぐ簡単な方法は?</div>
      <div class="quiz-answer">トランザクションを使い、必要に応じて行ロック（SELECT ... FOR UPDATE）を取得して排他制御する。</div>
      <span class="important"><strong>ポイント:</strong> トランザクションの開始/終了（BEGIN/COMMIT）は可視性と整合性を決める重要な境界です。</span>
    </section>

    <section class="fes-section" id="exp-b">
      <h3>実験B：ファントムリードとノンリピータブルリード</h3>
      <p>ミッション: 集計処理中にデータが増えるとどうなるかを観察し、隔離レベルを変えて結果がどう変わるか確認します。</p>
      <ol>
        <li>セッションA: BEGIN; SELECT SUM(balance) FROM accounts; （結果をメモ）</li>
        <li>セッションB: INSERT INTO accounts (name, balance) VALUES ('C', 4000); COMMIT;</li>
        <li>セッションA: 再度 SELECT SUM(balance) FROM accounts; → 結果が変わる（ノンリピータブルリード / ファントム）</li>
      </ol>
      <div class="code-block">
        <pre><code class="language-sql">-- セッションA
BEGIN;
SELECT SUM(balance) AS total_before FROM accounts;

-- セッションB
INSERT INTO accounts (name, balance) VALUES ('C', 4000);
COMMIT;

-- セッションA 再度
SELECT SUM(balance) AS total_after FROM accounts;

-- 対策: セッションA を REPEATABLE READ で実行すると...
-- セッションA
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
SELECT SUM(balance) FROM accounts; -- そのトランザクション内では追加行が見えない
</code></pre>
      </div>
      <p>解説: <strong>READ COMMITTED</strong> では別セッションのコミットが見えるが、<strong>REPEATABLE READ</strong> や <strong>SERIALIZABLE</strong> を使うと同一トランザクション内で一貫したスナップショットが保証されます（SERIALIZABLE はさらに衝突時にエラーを出す）。</p>
      <div class="quiz-question" onclick="toggleAnswer(this)"><strong>実行結果例（正常動作）を表示</strong></div>
      <div class="quiz-answer"><div class="result-block">
        <pre><code class="language-sql">BEGIN
 total_before
--------------
         7000
(1 行)

INSERT 0 1
COMMIT
 total_after
-------------
       11000
(1 行)

SET
BEGIN
  sum
-------
 11000
(1 行)</code></pre>
      </div></div>
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. ノンリピータブルリードとは何か?</div>
      <div class="quiz-answer">同一トランザクション内で同じSELECTを2回実行したときに結果が変わる現象。READ COMMITTEDで発生しやすい。</div>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. ファントムリードとどこが違う?</div>
      <div class="quiz-answer">ファントムリードは集計や範囲検索で行の出現/非出現が変わる現象（新しい行が見える）。ノンリピータブルは既存行の値の変化を指す場合が多い。</div>
      <span class="important"><strong>ポイント:</strong> 一貫性が重要な集計処理では隔離レベルを上げるか、アプリでリトライ設計を行いましょう。</span>
    </section>

    <section class="fes-section" id="exp-c">
      <h3>実験C：デッドロックをわざと起こす</h3>
      <p>デッドロックとは、複数のトランザクションがお互いに相手が保持するロックの解除を待っている状態（循環待ち）を指します。各トランザクションは進行できず、システム全体が停滞するため、データベースは検出時にどちらか一方を強制的にロールバックして待ちを解消します。本実験では発生条件と検出時の出力を確認し、回避策を考えます。</p>
      <p>目的: デッドロック発生の仕組みを体験し、PostgreSQL の検知と解決（片方のトランザクションをロールバック）の動作を確認する。</p>
      <div class="code-block">
        <pre><code class="language-sql">-- 準備: テーブルに2行用意
TRUNCATE TABLE accounts;
INSERT INTO accounts (name, balance) VALUES ('X', 100), ('Y', 200);

-- セッションA
BEGIN;
UPDATE accounts SET balance = balance + 10 WHERE id = 1; -- ロック1

-- セッションB
BEGIN;
UPDATE accounts SET balance = balance + 20 WHERE id = 2; -- ロック2

-- セッションA が次に id=2 の更新を試みる
UPDATE accounts SET balance = balance - 5 WHERE id = 2; -- ここで待ち発生

-- セッションB が次に id=1 の更新を試みる
UPDATE accounts SET balance = balance - 5 WHERE id = 1; -- デッドロック検知 → エラー
</code></pre>
      </div>
      <p>演習: 発生したエラーメッセージ（デッドロック検知）を確認し、どのトランザクションがロールバックされたかを説明してください。</p>
      <div class="quiz-question" onclick="toggleAnswer(this)"><strong>実行結果例（正常動作）を表示</strong></div>
      <div class="quiz-answer"><div class="result-block">
        <pre><code class="language-sql">
    TRUNCATE TABLE
    INSERT 0 2
    BEGIN
    UPDATE 0
    BEGIN
    UPDATE 0
    UPDATE 0
    UPDATE 0</code></pre>
      </div></div>
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. デッドロック検知の結果、PostgreSQLはどう処理するか?</div>
      <div class="quiz-answer">デッドロックを検出すると、どちらか一方のトランザクションを強制的にロールバックして待ちを解消する（エラーを返す）。</div>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. デッドロックを避ける実務的な方法は?</div>
      <div class="quiz-answer">共通のロック順序を守る、ロック粒度を見直す、短時間でコミットするようにトランザクションを設計するなど。</div>
      <span class="important"><strong>ポイント:</strong> トランザクション内でのロック順序を統一するとデッドロックの発生確率が下がります。</span>
    </section>

    <section class="fes-section" id="exercise">
      <h3>演習課題：在庫管理システムの悲劇</h3>
      <p>問題: 在庫残り1個の商品を、2人が同時に購入ボタンを押した。データがマイナスにならないようにするには、どの時点でどんなロックを取るべきか？</p>
      <p>解答例のヒントとサンプルSQL:</p>
      <div class="code-block">
        <pre><code class="language-sql">-- 在庫テーブル例
CREATE TABLE IF NOT EXISTS stock (
  product_id INT PRIMARY KEY,
  qty INT NOT NULL
);

-- 安全な購入処理のサンプル（トランザクション内で SELECT ... FOR UPDATE を使う）
BEGIN;
-- 1) 在庫行を排他ロックで読み取る
SELECT qty FROM stock WHERE product_id = 1 FOR UPDATE;

-- 2) 在庫があれば更新（減算）
UPDATE stock SET qty = qty - 1 WHERE product_id = 1 AND qty > 0;

-- 3) 成功なら COMMIT、失敗なら ROLLBACK
COMMIT;
</code></pre>
      </div>
      <p>説明: <code>SELECT ... FOR UPDATE</code> で該当行をロックしてから在庫チェックと更新を行うことで、同時更新によるオーバーセールを防ぎます。</p>
        <div class="quiz-question" onclick="toggleAnswer(this)"><strong>実行結果例（正常動作）を表示</strong></div>
        <div class="quiz-answer"><div class="result-block">
          <pre><code class="language-sql">
      CREATE TABLE
      BEGIN
       qty
      -----
      (0 行)

      UPDATE 0
      COMMIT</code></pre>
        </div></div>
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. なぜ <code>SELECT ... FOR UPDATE</code> が有効なのか?</div>
      <div class="quiz-answer">当該行を排他ロックすることで、他トランザクションが同じ行を更新できなくし、チェック→更新の間に競合が起きないようにするため。</div>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. FOR UPDATE ではどのようなケースに注意するべきか?</div>
      <div class="quiz-answer">複数行をロックするとデッドロックやスループット低下の可能性があるため、必要最小限の行だけをロックする設計が重要。</div>
      <span class="important"><strong>ポイント:</strong> ロックは整合性を守るが、同時実行性を下げるトレードオフがある。必要箇所だけ使いましょう。</span>
      
      <h4>追加演習</h4>
      <ol>
        <li>
          <strong>演習1: 競合する振込処理の再現（中）</strong>
          <div class="code-block">
            <pre><code class="language-sql">-- セッションA
BEGIN;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;
UPDATE accounts SET balance = balance - 1000 WHERE id = 1;

-- セッションB（ほぼ同時）
BEGIN;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE; -- ここで待つ／またはブロックされる
UPDATE accounts SET balance = balance - 500 WHERE id = 1;
-- どの順で COMMIT するとどうなるか観察する
COMMIT;
</code></pre>
          </div>
          <p>狙い: FOR UPDATE による排他制御で待ちが発生し、Lost Update を防げることを確認する。</p>
        
        <div class="quiz-question" onclick="toggleAnswer(this)"><strong>実行結果例（正常動作）を表示</strong></div>
        <div class="quiz-answer"><div class="result-block">
          <pre><code class="language-sql">BEGIN
       balance
      ---------
      (0 行)

      UPDATE 0
      BEGIN
       balance
      ---------
      (0 行)

      UPDATE 0
      COMMIT</code></pre>
        </div></div>

        </li>

        <li>
          <strong>演習2: 楽観ロック（versionカラム）での実装（上）</strong>
          <div class="code-block">
            <pre><code class="language-sql">-- テーブルにバージョンカラムを追加
ALTER TABLE accounts ADD COLUMN IF NOT EXISTS version INT DEFAULT 0;

-- 更新時の実装例（アプリ側で実行）
-- 1) SELECT balance, version FROM accounts WHERE id = 1;
-- 2) アプリで new_balance を計算
-- 3) UPDATE accounts SET balance = :new_balance, version = version + 1 WHERE id = 1 AND version = :old_version;
-- 4) 更新件数が0なら競合発生としてリトライ
</code></pre>
          </div>
          <p>狙い: 排他ロックを使わずに衝突検知→リトライするパターンを学ぶ。高スループット向け。</p>
          <div class="quiz-question" onclick="toggleAnswer(this)"><strong>実行結果例（正常動作）を表示</strong></div>
          <div class="quiz-answer"><div class="result-block">
            <pre><code class="language-sql">ALTER TABLE</code></pre>
          </div></div>
        </li>

        <li>
          <strong>演習3: SERIALIZABLE とリトライ設計（上）</strong>
          <div class="code-block">
            <pre><code class="language-sql">-- セッションA
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;
-- 何らかの読み取り＋更新処理
SELECT SUM(balance) FROM accounts;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- 衝突があれば ERROR: could not serialize access と出る
-- アプリ側はこのエラーを受けてトランザクション全体を再試行する必要がある
</code></pre>
          </div>
          <p>狙い: 厳密な一貫性を確保する代わりに、衝突時のリトライが必要になることを体験する。</p>
          <div class="quiz-question" onclick="toggleAnswer(this)"><strong>実行結果例（正常動作）を表示</strong></div>
          <div class="quiz-answer"><div class="result-block">
            <pre><code class="language-sql">SET
BEGIN
  sum
-----
 300
(1 行)

UPDATE 0
COMMIT</code></pre>
          </div></div>
        </li>

        <li>
          <strong>演習4: 在庫のバルク購入での整合性検査（中）</strong>
          <div class="code-block">
            <pre><code class="language-sql">-- シナリオ: ユーザーがカートで複数商品を同時に購入
BEGIN;
-- 1) 対象商品の行を FOR UPDATE でまとめてロック
SELECT product_id, qty FROM stock WHERE product_id IN (1,2,3) FOR UPDATE;
-- 2) すべての在庫が足りるかチェックし、足りればUPDATEを実行
-- 注意: `:amount` のようなプレースホルダをそのまま psql に投げると構文エラーになります。
-- 方法A: psql の変数機能を使う例（psql 上で値をセットしてから実行）
-- \set amount 2
-- \set id 1
-- UPDATE stock SET qty = qty - :amount WHERE product_id = :id AND qty >= :amount;

-- 方法B: アプリやプリペアドステートメントでパラメータ化する例（サーバ側で安全に実行）
-- PREPARE purchase(INT, INT) AS
--   UPDATE stock SET qty = qty - $2 WHERE product_id = $1 AND qty >= $2;
-- EXECUTE purchase(1, 2);
-- DEALLOCATE purchase;
COMMIT;
</code></pre>
          </div>
          <div class="quiz-question" onclick="toggleAnswer(this)"><strong>実行結果例（正常動作）を表示</strong></div>
          <div class="quiz-answer"><div class="result-block">
            <pre><code class="language-sql">
BEGIN
 product_id | qty
------------+-----
(0 行)

COMMIT</code></pre>
          </div></div>
          <p>狙い: 複数行を一括でロックする際のデッドロック回避（ロック順序の統一）の重要性を考える。</p>
        </li>

        <li>
          <strong>演習5: 監査ログを使った不整合検出（軽）</strong>
          <div class="code-block">
            <pre><code class="language-sql">-- 変更履歴テーブル例
CREATE TABLE IF NOT EXISTS accounts_audit (
  id SERIAL PRIMARY KEY,
  account_id INT,
  old_balance INT,
  new_balance INT,
  changed_at TIMESTAMP DEFAULT now()
);

-- トランザクション内で更新と同時に監査ログを挿入
-- 注意: `CREATE TABLE IF NOT EXISTS` は既存時に NOTICE を出しますが処理は継続され安全です。
-- psql の `\gset` は戻り行が無い場合にエラーになります。安全に処理する例を示します。
-- 方法A: PL/pgSQL の匿名ブロックで更新と監査を安全に行う（0行でもエラーにならない）
DO $$
DECLARE
  rec RECORD;
BEGIN
  UPDATE accounts
  SET balance = balance - 100
  WHERE id = 1
  RETURNING id AS account_id, (balance + 100) AS old_balance, balance AS new_balance
  INTO rec;
  IF FOUND THEN
    INSERT INTO accounts_audit (account_id, old_balance, new_balance)
    VALUES (rec.account_id, rec.old_balance, rec.new_balance);
  END IF;
END
$$;

-- 方法B: WITH を使って UPDATE の戻り値をそのまま挿入する（シンプルで安全）
WITH upd AS (
  UPDATE accounts
  SET balance = balance - 100
  WHERE id = 1
  RETURNING id AS account_id, (balance + 100) AS old_balance, balance AS new_balance
)
INSERT INTO accounts_audit (account_id, old_balance, new_balance)
SELECT account_id, old_balance, new_balance FROM upd;
</code></pre>
          </div>
          <div class="quiz-question" onclick="toggleAnswer(this)"><strong>実行結果例（正常動作）を表示</strong></div>
          <div class="quiz-answer"><div class="result-block">
            <pre><code class="language-sql">CREATE TABLE
DO
INSERT 0 0</code></pre>
          </div></div>
          <p>狙い: 監査ログを使って競合や想定外の変更を後から検出する手法を紹介。</p>
        </li>
      </ol>

      <h4>追加演習の定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)"><strong>楽観ロック:</strong> 更新件数チェックで競合検知→リトライの流れはどうなるか?</div>
      <div class="quiz-answer">アプリはまず現在の `version` や `balance` を読み取り、更新時に `WHERE version = :old_version` を使って更新件数を確認します。更新件数が0なら競合としてリトライします。これにより排他ロックを使わず高スループットを維持できます。</div>

      <div class="quiz-question" onclick="toggleAnswer(this)"><strong>SERIALIZABLE:</strong> SERIALIZABLE を使うとアプリ側で何を実装する必要があるか?</div>
      <div class="quiz-answer">衝突時に `could not serialize access` エラーが返るため、アプリはそのエラーを受けてトランザクション全体を再試行する実装が必要です。リトライ回数やバックオフ戦略も設計に含めます。</div>

      <div class="quiz-question" onclick="toggleAnswer(this)"><strong>バルクロック:</strong> 複数行をまとめてロックする際の注意点は何か?</div>
      <div class="quiz-answer">ロックする行の順序を統一し、必要最小限の行だけをロックすることでデッドロック発生確率を下げます。また長時間のトランザクションは避けて短時間でコミットする設計が有効です。</div>
    </section>

    <section class="fes-section" id="checks">
      <h3>学習チェックリスト</h3>
      <div class="quiz-question" onclick="toggleAnswer(this)">1) READ COMMITTED / REPEATABLE READ / SERIALIZABLE の主な違いは何か?</div>
      <div class="quiz-answer">READ COMMITTED は各クエリ時点でコミット済みデータを参照する。REPEATABLE READ はトランザクション開始時のスナップショットを維持しファントム回避に強い。SERIALIZABLE は仮想的に直列化された実行を保証し、衝突時にエラーを返す。</div>

      <div class="quiz-question" onclick="toggleAnswer(this)">2) `SELECT ... FOR UPDATE` の用途と副作用は?</div>
      <div class="quiz-answer">特定行を排他ロックしてチェック→更新の間に他トランザクションからの更新を防ぐ。副作用として待ちやデッドロックの発生、同時実行性の低下がある。</div>

      <div class="quiz-question" onclick="toggleAnswer(this)">3) デッドロックの原因と基本的な回避策は?</div>
      <div class="quiz-answer">原因は複数トランザクションが互いに相手のロック解除を待つ循環待ち。回避策はロック順序の統一、トランザクションの短縮、必要最小限のロック、楽観ロックの活用など。</div>

      <div class="quiz-question" onclick="toggleAnswer(this)">4) 楽観ロックはどんな場面で有効か?</div>
      <div class="quiz-answer">競合が稀でスループットを優先したい処理に有効。衝突時はリトライで対応するため、短時間で再試行できる設計が必要。</div>

      <div class="quiz-question" onclick="toggleAnswer(this)">5) SERIALIZABLE を選ぶときの注意点は?</div>
      <div class="quiz-answer">一貫性は強く保証されるが、衝突時のリトライが発生し得るためアプリ側で再試行ロジックと適切なバックオフを実装する必要がある。</div>

      <div class="quiz-question" onclick="toggleAnswer(this)">6) 一貫性と同時実行性のトレードオフをどう考えるか?</div>
      <div class="quiz-answer">重要なデータ整合性が必要なら隔離レベルを上げたりロックを使う。高負荷時は楽観ロックやアプリ側での補償（リトライ設計）を検討し、必要に応じて整合性要件を緩める判断を行う。</div>

      <h4>補足問題</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">補足Q: SERIALIZABLE を使うと性能が必ず低下するか?</div>
      <div class="quiz-answer">必ずしも低下しないが、衝突時にトランザクションがエラーとなりリトライが必要になるため、アプリ設計側での対処が必要になる点に注意。</div>
    </section>

    <section class="fes-section" id="summary">
      <h3>まとめ</h3>
      <ul>
        <li>隔離レベル（READ COMMITTED / REPEATABLE READ / SERIALIZABLE）は可視性と一貫性を決める重要な要素であり、要件に応じて使い分ける必要がある。</li>
        <li>行ロック（`SELECT ... FOR UPDATE`）は簡潔で確実な排他制御を提供するが、待ちやデッドロック、同時実行性低下といった副作用がある。</li>
        <li>楽観ロック（versionカラムや更新件数チェック）は競合が稀な高スループット用途で有効。衝突時はリトライ実装が必要。</li>
        <li>デッドロックはロックの循環待ちで発生するため、ロック順序の統一や短時間のトランザクション設計で発生確率を下げられる。</li>
        <li>SERIALIZABLE は最も強い一貫性を提供するが、衝突時にアプリ側での再試行が必須になる点を設計に含めること。</li>
      </ul>
    </section>

    <section class="fes-section" id="next-steps">
      <h3>次のステップ</h3>
      <ol>
        <li>ローカル環境で各実験（A〜C）を実際に再現し、隔離レベルを切り替えたときの出力差を観察する。</li>
        <li>演習の在庫シナリオをアプリ側で実装してみる（楽観ロックと悲観ロックの両方を試す）。</li>
        <li>デッドロックを発生させてログ（PostgreSQLのエラーメッセージ）を確認し、どの更新がロールバックされたかを追跡する。</li>
        <li>性能観点で比較するため、簡単な負荷試験（同時接続数を増やしてスループット・レイテンシを測る）を行い、隔離レベルやロック戦略のトレードオフを評価する。</li>
        <li>本ページのコード説明や出力例を踏まえて、実務での設計方針（いつ楽観ロックを採るか、どの処理をSERIALIZABLEにするか）をドキュメント化する。</li>
        <li>（任意）スタイルの整理：`style.css` にコード関連スタイルを移してメンテしやすくする。</li>
      </ol>
    </section>

    <div style="margin-top: 28px; text-align: center;">
      <div style="display: inline-block; padding: 10px 14px; background: #222; color: #fff; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.25); font-weight: 700; font-size: 1rem;">
        本コンテンツの作成時間： <span style="color: #ffd54f;">約13時間</span>
      </div>
      <div style="margin-top: 10px;">
        <a href="index.html" class="back-to-home">← トップに戻る</a>
      </div>
    </div>

    <script>
      function toggleMenu() {
        var navigation = document.getElementById("navigation");
        if (navigation.style.display === "block") {
          navigation.style.display = "none";
        } else {
          navigation.style.display = "block";
        }
      }
      function toggleAnswer(element) {
        var answer = element.nextElementSibling;
        if (answer && answer.classList.contains('quiz-answer')) {
          answer.classList.toggle('show');
        }
      }

      function addCopyButtons() {
        document.querySelectorAll('.code-block').forEach(function(cb) {
          // avoid adding multiple buttons
          if (cb.querySelector('.copy-btn')) return;
          cb.style.position = cb.style.position || 'relative';
          var btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'copy-btn';
          btn.setAttribute('aria-label', 'コードをコピー');
          btn.textContent = 'コピー';
          btn.addEventListener('click', function() {
            var codeEl = cb.querySelector('pre code') || cb.querySelector('code') || cb.querySelector('pre');
            if (!codeEl) return;
            var text = codeEl.innerText;
            if (navigator.clipboard && navigator.clipboard.writeText) {
              navigator.clipboard.writeText(text).then(function() {
                btn.textContent = 'コピー済み';
                btn.classList.add('copied');
                setTimeout(function() { btn.textContent = 'コピー'; btn.classList.remove('copied'); }, 1800);
              }).catch(function() { fallbackCopy(text, btn); });
            } else {
              fallbackCopy(text, btn);
            }
          });
          cb.appendChild(btn);
        });
      }

      function fallbackCopy(text, btn){
        try {
          var ta = document.createElement('textarea');
          ta.value = text;
          ta.style.position = 'fixed'; ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          btn.textContent = 'コピー済み';
          btn.classList.add('copied');
          setTimeout(function() { btn.textContent = 'コピー'; btn.classList.remove('copied'); }, 1800);
        } catch (e) {
          alert('コピーに失敗しました。手動で選択してコピーしてください。');
        }
      }

      document.addEventListener('DOMContentLoaded', function() {
        const sections = document.querySelectorAll('.fes-section');
        sections.forEach(function(section) {
          const heading = section.querySelector('h3');
          if (heading) {
            heading.addEventListener('click', function() {
              section.classList.toggle('collapsed');
            });
          }
        });
        addCopyButtons();
          addExerciseCodeToggles();
          addCodeExplanations();
          addResultExplanations();
      });
      
        function addExerciseCodeToggles(){
          document.querySelectorAll('#exercise .code-block').forEach(function(cb){
            // avoid adding multiple toggles
            if (cb.querySelector('.code-toggle-btn')) return;
            var codeEl = cb.querySelector('pre');
            if (!codeEl) return;
            // hide the code initially
            codeEl.classList.add('exercise-hidden');

            var btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'code-toggle-btn';
            btn.setAttribute('aria-label','コードを表示');
            btn.textContent = 'コードを表示';
            btn.addEventListener('click', function(){
              if (codeEl.classList.contains('exercise-hidden')){
                codeEl.classList.remove('exercise-hidden');
                btn.textContent = 'コードを隠す';
                btn.setAttribute('aria-label','コードを隠す');
              } else {
                codeEl.classList.add('exercise-hidden');
                btn.textContent = 'コードを表示';
                btn.setAttribute('aria-label','コードを表示');
              }
              
            });
            cb.appendChild(btn);
          });
        }

        function addCodeExplanations(){
          document.querySelectorAll('.code-block').forEach(function(cb){
            // avoid adding multiple explanations
            if (cb.nextElementSibling && cb.nextElementSibling.classList && cb.nextElementSibling.classList.contains('code-explain')) return;
            var section = cb.closest('section');
            var heading = section ? section.querySelector('h3') : null;
            var title = heading ? heading.textContent.trim() : '';
            var text = '';
            if (/準備|prep|準備/.test(title) || (section && section.id==='prep')){
              text = 'このスニペットはテーブル作成、初期データ挿入とセッション確認のための手順です。実運用環境で実行する前はバックアップを取り、TRUNCATEやINSERTによるデータ消失に注意してください。psqlで複数のセッションを使って動作を観察する演習用途向けです。';
            } else if (/READ COMMITTED|実験A|exp-a/.test(title) || (section && section.id==='exp-a')){
              text = 'この例はトランザクション境界（BEGIN/COMMIT）と可視性の違いを観察するための手順です。READ COMMITTEDでは各クエリ実行時にコミット済みの最新状態を見るため、未コミットの変更は別セッションから見えません。手順を追って、更新の可視化とコミット後の挙動を確認してください。';
            } else if (/ファントム|ノンリピータブル|exp-b/.test(title) || (section && section.id==='exp-b')){
              text = '集計や範囲検索で「ファントム」や「ノンリピータブルリード」が発生する様子を再現するサンプルです。REPEATABLE READやSERIALIZABLEに切り替えた時のスナップショットの取り方と、衝突時のアプリ側でのリトライ設計についても考察してください。';
            } else if (/デッドロック|exp-c/.test(title) || (section && section.id==='exp-c')){
              text = 'あえて更新順序を入れ替えてデッドロックを発生させる手順です。PostgreSQLはデッドロックを検出するとどちらかのトランザクションをロールバックします。デッドロックのログやエラーメッセージの読み方、回避策（ロック順序の統一や短時間コミット）も確認しましょう。';
            } else if (/在庫|演習|exercise/.test(title) || (section && section.id==='exercise')){
              text = '在庫管理の実装課題向けのサンプルです。トランザクション内で `SELECT ... FOR UPDATE` による行ロックを行ってから在庫チェックと更新を行うことで、オーバーセールを防げます。さらに、デッドロックやスループットの影響、楽観ロックへの切替え設計も検討してください。';
            } else {
              text = 'このコード例は該当セクションで示した操作の具体例です。実行前に入力値や前提テーブルの状態、ロールバック時の影響を理解してから試してください。アプリ側でパラメータ化・プリペアドステートメントを使うことを推奨します。';
            }
            var div = document.createElement('div');
            div.className = 'code-explain';
            div.textContent = text;
            // insert after the code-block
            cb.parentNode.insertBefore(div, cb.nextSibling);
          });
        }

        function addResultExplanations(){
          document.querySelectorAll('.quiz-answer .result-block').forEach(function(rb){
            // avoid adding multiple explanations
            if (rb.nextElementSibling && rb.nextElementSibling.classList && rb.nextElementSibling.classList.contains('result-explain')) return;
            var section = rb.closest('section');
            var heading = section ? section.querySelector('h3') : null;
            var title = heading ? heading.textContent.trim() : '';
            var text = '';
            if (/準備|prep|準備/.test(title) || (section && section.id==='prep')){
              text = 'この出力はテーブル作成や初期データ挿入、セッション確認などのコマンドが正常に実行された際にpsqlが返す典型的なメッセージです。環境によっては NOTICE や WARNING が表示されることもあるため、実行前にコマンドの影響範囲を理解しておきましょう。';
            } else if (/READ COMMITTED|実験A|exp-a/.test(title) || (section && section.id==='exp-a')){
              text = 'BEGIN／UPDATE／COMMIT とそれに続く SELECT の出力例です。未コミットの変更は他セッションから見えないため、手順どおりに実行すると可視性の違いが結果に反映されます。ログや出力のタイミングを注意深く読み取りましょう。';
            } else if (/ファントム|ノンリピータブル|exp-b/.test(title) || (section && section.id==='exp-b')){
              text = '集計（SUM など）や INSERT の出力例です。別セッションでコミットが行われると集計結果が変化する様子が観察できます。隔離レベルを切り替えたときのスナップショット挙動の違いを比較して理解を深めてください。';
            } else if (/デッドロック|exp-c/.test(title) || (section && section.id==='exp-c')){
              text = 'デッドロック発生時の出力例です。通常は待ちが発生し、PostgreSQL が自動でデッドロックを検出してどちらか一方をロールバックします。出力されるエラーメッセージやログから、どの更新が原因で競合したかを特定する手順も学びましょう。';
            } else if (/演習|在庫|exercise/.test(title) || (section && section.id==='exercise')){
              text = '演習の期待出力例です。実行環境、トランザクションの状態、既存データによって結果は変動します。実際の実行結果と見比べて、差分がある場合はロック状態や隔離レベル、前提データの整合性を確認して原因を特定してください。';
            } else {
              text = 'これは想定される出力例であり、環境差によって表示が微妙に異なることがあります。出力の主要なポイント（CREATE/INSERT/UPDATE の応答、SELECT の結果行数など）を手がかりに、SQL が期待通りに動作しているか検証してください。';
            }
            var div = document.createElement('div');
            div.className = 'result-explain';
            div.textContent = text;
            rb.parentNode.insertBefore(div, rb.nextSibling);
          });
        }
    </script>
  </body>
</html>
