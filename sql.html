<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>SQL/Index 解説 - Kazushi's portfolio</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
  </head>
  <body>
    <!-- ハンバーガーメニューアイコン -->
    <div class="menu-icon" onclick="toggleMenu()">
      <span></span>
      <span></span>
      <span></span>
    </div>

    <h1><a href="index.html" style="color: lemonchiffon; text-decoration: none;">Kazushi's portfolio</a></h1>

    <nav class="navigation" id="navigation">
      <ul>
        <li><a href="index.html" onclick="toggleMenu()">Home</a></li>
        <li><a href="profile.html" onclick="toggleMenu()">Profile</a></li>
        <li><a href="skills.html" onclick="toggleMenu()">Skills</a></li>
        <li><a href="fes.html" onclick="toggleMenu()">高専祭</a></li>
        <li><a href="works.html" onclick="toggleMenu()">作品</a></li>
        <li>
          <a href="sql.html" onclick="toggleMenu()">SQL解説</a>
          <ul style="list-style: none; padding-left: 20px; margin-top: 5px;">
            <li><a href="#section-intro" onclick="toggleMenu()">・ ガイド概要</a></li>
            <li><a href="#section-1" onclick="toggleMenu()">・ 第1部 準備編</a></li>
            <li><a href="#section-2" onclick="toggleMenu()">・ 第2部 基礎編</a></li>
            <li><a href="#section-3" onclick="toggleMenu()">・ 第3部 応用編</a></li>
            <li><a href="#section-3-5" onclick="toggleMenu()">・ 第3.5部 実践編</a></li>
            <li><a href="#section-4" onclick="toggleMenu()">・ 第4部 発展編</a></li>
            <li><a href="#section-5" onclick="toggleMenu()">・ 第5部 総合演習</a></li>
            <li><a href="#section-6" onclick="toggleMenu()">・ 第6部 運用編</a></li>
            <li><a href="#section-summary" onclick="toggleMenu()">・ まとめ</a></li>
          </ul>
        </li>
        <li><a href="procon.html" onclick="toggleMenu()">高専プロコン</a></li>
      </ul>
    </nav>

    <h2>遅いクエリを救え！ PostgreSQL 17 で学ぶインデックス設計と実行計画の解読法</h2>

    <section class="fes-section" id="section-intro">
      <h3>ガイド概要</h3>
      <p><strong>学習時間の目安:</strong> 90分〜120分</p>
      <p>題材は架空の「ECサイトの大規模注文データ (100万件〜)」。データ量をしっかり用意し、PostgreSQL 17 の実行計画を読み解きながらインデックス設計の勘所を学びます。</p>
    </section>

    <section class="fes-section">
      <h3>インデックス設計とは何か</h3>
      <p>データベースのインデックスは、本の目次や索引に似た仕組みです。目次なしでは目的のページを探すために全ページを順番に読む必要がありますが、目次があれば一瞬で該当ページに辿り着けます。</p>
      
      <h4>インデックスの基本原理</h4>
      <p>データベースのインデックスは主にB-Tree（バランス木）構造で実装されており、データを階層的に整理します。これにより検索操作は $O(\log N)$ の計算量で実行でき、全件スキャン（$O(N)$）と比べて劇的に高速化されます。</p>
      
      <h4>インデックス設計の重要性</h4>
      <ul>
        <li><strong>検索性能の向上:</strong> WHERE句やJOINの条件に使われる列にインデックスを作成することで、クエリ実行時間を数秒から数ミリ秒に短縮できます</li>
        <li><strong>ソート処理の最適化:</strong> ORDER BY句で使う列にインデックスがあれば、ソート処理をスキップできる場合があります</li>
        <li><strong>トレードオフの理解:</strong> インデックスは検索を高速化しますが、INSERT/UPDATE/DELETEの性能は低下し、ストレージも消費します</li>
        <li><strong>適切な設計が不可欠:</strong> 不適切なインデックスは効果がないだけでなく、メンテナンスコストを増やします</li>
      </ul>
      
      <h4>このガイドで学ぶこと</h4>
      <p>本ガイドでは、単にインデックスの作り方を覚えるのではなく、PostgreSQLがどのようにインデックスを使うか（または使わないか）を理解し、実際の業務で「なぜ遅いのか」「どう改善すべきか」を判断できる力を養います。EXPLAIN ANALYZEを使った実行計画の読み方、カーディナリティと選択率の概念、複合インデックスの設計戦略など、実践的なスキルを段階的に習得します。</p>
    </section>

    <section class="fes-section" id="section-1">
      <h3>第1部 準備編: 戦うためのデータを揃える </h3>
      <p>インデックスの効果はデータ量があってこそ。数件ではシーケンシャルスキャンの方が速く、差が見えません。偏りを持たせたダミーデータを生成し、後の実験の伏線にします。</p>
      <ol>
        <li>orders テーブルを作成</li>
        <li>generate_series と random で 100万〜500万件を投入</li>
        <li>status に偏りを持たせる (例: completed 90%, cancelled 1%, pending 9%)</li>
      </ol>
      <h4>データ生成SQL</h4>
      <div class="code-block">
        <pre><code class="language-sql">CREATE TABLE orders (
  order_id     BIGSERIAL PRIMARY KEY,
  user_id      INTEGER NOT NULL,
  order_date   DATE    NOT NULL,
  status       TEXT    NOT NULL,
  total_amount NUMERIC(10,2) NOT NULL
);

INSERT INTO orders (user_id, order_date, status, total_amount)
SELECT (random()*100000)::int + 1 AS user_id,
       (DATE '2023-01-01' + (random()*365)::int) AS order_date,
       CASE
         WHEN random() &lt; 0.90 THEN 'completed'
         WHEN random() &lt; 0.91 THEN 'cancelled'
         ELSE 'pending'
       END AS status,
       round((random()*50000)::numeric, 2) AS total_amount
FROM generate_series(1, 1500000);
</code></pre>
      </div>
      <p>偏りを作ることで、後半の「インデックスが使われないケース」を再現できます。</p>
      
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. なぜ偏りのあるデータを生成する必要があるのか?</div>
      <div class="quiz-answer">後半の実験で「インデックスが使われないケース」を再現するため。データの9割がcompletedであれば、PostgreSQLはSeq Scanを選択しやすくなり、カーディナリティと選択率の実験に適したデータとなります。</div>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. generate_series関数の役割は何か?</div>
      <div class="quiz-answer">指定した範囲（この場合は1～1500000）の連続した数値を生成する関数。大量のダミーデータを効率的に作成するために使用します。</div>
    </section>

    <section class="fes-section" id="section-2">
      <h3>第2部 基礎編: B-Treeインデックスの威力とコスト </h3>
      <p>まずは王道の等価検索で、シーケンシャルスキャンとインデックススキャンの速度差を体験します。計算量は $O(N)$ vs $O(\log N)$。</p>
      <h4>実験1: 干し草の山から針を探す</h4>
      <ol>
        <li>PRIMARY KEY が既に設定されているため、インデックス Scan の効果を確認</li>
        <li>その他の列（例：status）での検索パターンと比較</li>
      </ol>
      <h4>実行SQL</h4>
      <div class="code-block">
        <pre><code class="language-sql">-- 主キーによるインデックススキャン（高速）
EXPLAIN ANALYZE
SELECT * FROM orders WHERE order_id = 424242;

-- 比較: インデックスなしの検索パターン
-- （第3部で実装）
</code></pre>
      </div>

      <h4>実行結果例</h4>
      <div class="result-block">
        <pre><code class="language-sql">                                                     QUERY PLAN                                          

---------------------------------------------------------------------------------------------------------------------
 Index Scan using orders_pkey on orders  (cost=0.43..8.45 rows=1 width=33) (actual time=0.058..0.059 rows=1 loops=1)
   Index Cond: (order_id = 424242)
 Planning Time: 3.580 ms
 Execution Time: 1.192 ms
(4 行)
</code></pre>
      </div>

      <h4>結果の解釈</h4>
      <ul>
        <li><strong>Index Scan using orders_pkey:</strong> 主キーのインデックスが効果的に使われている</li>
        <li><strong>cost=0.43..8.45:</strong> 推定コストが非常に低い（全件スキャンの場合は数百以上になる）</li>
        <li><strong>actual time=0.058..0.059 rows=1:</strong> 実測時間はわずか0.059ミリ秒</li>
        <li><strong>Execution Time: 1.192 ms:</strong> 全体の実行時間も高速</li>
      </ul>
      <span class="important"><strong>ポイント:</strong> Execution Timeが1ミリ秒未満であることは、インデックスが効果的に機能している証拠です。これを第3部のSeq Scanと比較することで、インデックスの威力を実感できます。</span>
      
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. インデックススキャン後、実行計画の Cost はどう変化したか?</div>
      <div class="quiz-answer">Costが大幅に減少します。Seq Scanは全行をスキャンするためデータ量に比例したコスト（O(N)）がかかりますが、Index Scanはログオーダー（O(log N)）で目的の行を見つけられるため、データ量が多いほど差が顕著になります。</div>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. なぜデータ量が増えると Seq Scan は遅くなるのか?</div>
      <div class="quiz-answer">Seq Scanは全行を順番に読み込む必要があるため、データ量に比例して処理時間が増加します（O(N)）。一方、B-Treeインデックスを使用すると木構造を辿るだけで済むため、データ量が増えても対数的な増加（O(log N)）に抑えられます。</div>
      
      <h4>EXPLAIN ANALYZEの読み方</h4>
      <p>実行計画を読み解く力は、チューニングの基本です。主な出力項目の意味を理解しましょう。</p>
      <ul>
        <li><strong>Seq Scan on orders:</strong> テーブル全体を順次スキャン。データ量に比例してコストが増加</li>
        <li><strong>Index Scan using orders_pkey:</strong> インデックスを使って効率的に検索。ログオーダーの性能</li>
        <li><strong>Index Only Scan:</strong> インデックスだけで全データ取得。テーブルアクセス不要で最速</li>
        <li><strong>Bitmap Heap Scan:</strong> 中間的な方法。複数行をまとめて効率的に取得</li>
        <li><strong>cost=0.00..8.27:</strong> 推定コスト（開始..終了）。小さいほど高速と予測</li>
        <li><strong>rows=1:</strong> 推定行数。統計情報から算出</li>
        <li><strong>actual time=0.015..0.016:</strong> 実測時間（ミリ秒）。実際の性能</li>
        <li><strong>Planning Time:</strong> 実行計画の作成時間</li>
        <li><strong>Execution Time:</strong> 実際のクエリ実行時間</li>
      </ul>
      <span class="important"><strong>重要:</strong> costは推定値、actual timeが実測値です。両者に大きな乖離がある場合、統計情報の更新（ANALYZE）が必要かもしれません。</span>
      
      <p><strong>SQLドリル:</strong> 以下のクエリの実行計画を読み解き、どのようにインデックスが使われているか説明してみよう。</p>
      <div class="quiz-question" onclick="toggleAnswer(this)">SQLドリルの解答例を表示</div>
      <div class="quiz-answer">このドリルでは、複数の検索パターンで実行計画を比較し、インデックスの使用状況を観察します。
        <div class="code-block">
          <pre><code class="language-sql">-- パターン1: 主キーによる検索（最速）
EXPLAIN ANALYZE
SELECT * FROM orders WHERE order_id = 100000;

-- パターン2: 範囲検索（主キー）
EXPLAIN ANALYZE
SELECT COUNT(*) FROM orders WHERE order_id BETWEEN 1 AND 10000;

-- パターン3: インデックスがない列での検索
EXPLAIN ANALYZE
SELECT * FROM orders WHERE total_amount > 40000;

-- パターン4: 集計関数とインデックス
EXPLAIN ANALYZE
SELECT MAX(order_id), MIN(order_id) FROM orders;
</code></pre>
        </div>
        <p><strong>観察ポイント</strong></p>
        <ul>
          <li><strong>パターン1:</strong> Index Scan using orders_pkey が選ばれ、cost/actual timeが非常に小さい（~0.01ms）</li>
          <li><strong>パターン2:</strong> Index Only Scanが選ばれる可能性が高い。COUNT(*)はインデックスだけで計算可能</li>
          <li><strong>パターン3:</strong> total_amountにインデックスがないため、Seq Scanになり実行時間が長い（数百ms）</li>
          <li><strong>パターン4:</strong> MAX/MINは主キーインデックスを使って瞬時に計算される（Result + Index Only Scan）</li>
        </ul>
        <p>実行計画を見る際は、①どのスキャン方式が選ばれたか、②costと実測時間の関係、③rows推定と実際の行数の乖離に注目しましょう。</p>
        
        <p><strong>実行結果例（正常動作）</strong></p>
        <p><strong>パターン1: 主キーによる検索（最速）</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">                                                     QUERY PLAN                                          

---------------------------------------------------------------------------------------------------------------------
 Index Scan using orders_pkey on orders  (cost=0.43..8.45 rows=1 width=33) (actual time=2.402..2.405 rows=1 loops=1)
   Index Cond: (order_id = 100000)
 Planning Time: 7.798 ms
 Execution Time: 3.416 ms
(4 行)</code></pre>
        </div>
        <p><strong>パターン2: 範囲検索（主キー）+ COUNT</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">                                                               QUERY PLAN                                

----------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=327.58..327.59 rows=1 width=8) (actual time=4.841..4.842 rows=1 loops=1)
   ->  Index Only Scan using orders_pkey on orders  (cost=0.43..303.23 rows=9740 width=0) (actual time=0.041..4.480 rows=10000 loops=1)
         Index Cond: ((order_id >= 1) AND (order_id <= 10000))
         Heap Fetches: 0
 Planning Time: 0.985 ms
 Execution Time: 4.911 ms
(6 行)</code></pre>
        </div>
        <p><strong>パターン3: インデックスなし列での検索</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">                                                   QUERY PLAN                                            

-----------------------------------------------------------------------------------------------------------------
 Seq Scan on orders  (cost=0.00..31250.00 rows=295579 width=33) (actual time=0.151..581.529 rows=299946 loops=1)
   Filter: (total_amount > '40000'::numeric)
   Rows Removed by Filter: 1200054
 Planning Time: 1.360 ms
 Execution Time: 592.776 ms
(5 行)</code></pre>
        </div>
        <p><strong>パターン4: 集計関数とインデックス（MAX/MIN）</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">                                                                        QUERY PLAN                       

----------------------------------------------------------------------------------------------------------------------------------------------------------
 Result  (cost=0.91..0.92 rows=1 width=16) (actual time=1.936..1.938 rows=1 loops=1)
   InitPlan 1
     ->  Limit  (cost=0.43..0.45 rows=1 width=8) (actual time=1.907..1.908 rows=1 loops=1)
           ->  Index Only Scan Backward using orders_pkey on orders  (cost=0.43..38964.43 rows=1500000 width=8) (actual time=1.906..1.906 rows=1 loops=1)
                 Heap Fetches: 0
   InitPlan 2
     ->  Limit  (cost=0.43..0.45 rows=1 width=8) (actual time=0.023..0.023 rows=1 loops=1)
           ->  Index Only Scan using orders_pkey on orders orders_1  (cost=0.43..38964.43 rows=1500000 width=8) (actual time=0.022..0.022 rows=1 loops=1)
                 Heap Fetches: 0
 Planning Time: 0.287 ms
 Execution Time: 1.958 ms
(11 行)</code></pre>
        </div>
        
        <p><strong>結果の解釈</strong></p>
        <ul>
          <li><strong>パターン1:</strong> order_id=100000 という1行の検索が 3.4ms で完了。主キーインデックスが最適に機能</li>
          <li><strong>パターン2:</strong> Index Only Scan で 10,000行を集計。Heap Fetches: 0 は「テーブル本体に一度もアクセスしていない」ことを示す完璧な実行計画</li>
          <li><strong>パターン3:</strong> total_amount にインデックスがないため Seq Scan が選ばれ、150万行中約30万行にヒット。実行時間は 592ms と長い</li>
          <li><strong>パターン4:</strong> MAX/MIN は「インデックスの両端の値」を取得するだけなので、わずか1行のスキャンで完了。1.9ms は極めて高速</li>
          <li><strong>重要な発見:</strong> パターン1と2の「数ms」対パターン3の「数百ms」を比較すると、インデックスの有無で実行時間が100倍以上変わることが実証される</li>
        </ul>
      </div>
    </section>

    <section class="fes-section" id="section-3">
      <h3>第3部 応用編: インデックスが「使われない」謎を解く </h3>
      <p>インデックスを作ったのに遅い——よくあるトラブルを再現し、カーディナリティと選択率 (Selectivity) の境界を探ります。</p>
      <h4>実験2: カーディナリティと選択率</h4>
      <ul>
        <li>ケースA: status = 'completed' (全体の約90%) → Seq Scan が選ばれる</li>
        <li>ケースB: status = 'cancelled' (全体の約1%) → Bitmap Heap Scan または Index Scan が選ばれる</li>
      </ul>
      <h4>実行SQL</h4>
      <div class="code-block">
        <pre><code class="language-sql">CREATE INDEX idx_orders_status ON orders(status);
 
EXPLAIN ANALYZE
SELECT * FROM orders WHERE status = 'completed';
 
EXPLAIN ANALYZE
SELECT * FROM orders WHERE status = 'cancelled';
</code></pre>
      </div>

      <h4>実行結果例</h4>
      <p><strong>ケースA: status = 'completed'（全体の約90%）</strong></p>
      <div class="result-block">
        <pre><code class="language-sql">                                                    QUERY PLAN                                           

-------------------------------------------------------------------------------------------------------------------
 Seq Scan on orders  (cost=0.00..31250.00 rows=1353200 width=33) (actual time=0.070..304.200 rows=1349400 loops=1)
   Filter: (status = 'completed'::text)
   Rows Removed by Filter: 150600
 Planning Time: 1.767 ms
 Execution Time: 390.423 ms
(5 行)</code></pre>
      </div>

      <p><strong>ケースB: status = 'cancelled'（全体の約1%）</strong></p>
      <div class="result-block">
        <pre><code class="language-sql">                                                              QUERY PLAN                                 

---------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on orders  (cost=1499.05..15667.80 rows=133500 width=33) (actual time=7.905..64.702 rows=137194 loops=1)
   Recheck Cond: (status = 'cancelled'::text)
   Heap Blocks: exact=12500
   ->  Bitmap Index Scan on idx_orders_status  (cost=0.00..1465.68 rows=133500 width=0) (actual time=5.864..5.866 rows=137194 loops=1)
         Index Cond: (status = 'cancelled'::text)
 Planning Time: 0.105 ms
 Execution Time: 71.366 ms
(7 行)</code></pre>
      </div>

      <h4>結果の解釈</h4>
      <ul>
        <li><strong>ケースA (Seq Scan, 390.423ms):</strong> 全体の90%がヒットするため、インデックスを使うより全件スキャンの方がコスト効率が良い。PostgreSQLは正しく判断してSeq Scanを選択</li>
        <li><strong>ケースB (Bitmap Heap Scan, 71.366ms):</strong> 全体の1%しかヒットしないため、インデックスを活用したBitmap Scanが選ばれ、実行時間は390msの約1/5に短縮</li>
        <li><strong>実行時間の差：</strong> ケースAとケースBで約5倍以上の性能差が出ている。選択率（Selectivity）がインデックス利用判断を左右する実例</li>
        <li><strong>コスト推定の精度：</strong> 推定コストと実行時間が一致しており、ANALYZE実行後の統計情報が正確に機能している証拠</li>
      </ul>
      <span class="important"><strong>重要な学び:</strong> インデックスがあるからといって常に使われるわけではありません。選択率が高い場合は、Seq Scanの方が効率的という判断が、データベースの最適化エンジンによって自動で下されます。これが「PostgreSQLの正しい動作」です。</span>

      <p><strong>なぜ？</strong> 本を最初から読む (Seq Scan) か、目次を見る (Index Scan) かは「何件ヒットするか」の期待値で決まる。PostgreSQL は統計情報をもとにコストを見積もります。</p>
      <p><strong>SQLドリル:</strong> 日付範囲など別条件で、インデックスが効く境界 (ヒット件数の割合) を探ってみよう。</p>
      <div class="quiz-question" onclick="toggleAnswer(this)">SQLドリルの解答例を表示</div>
      <div class="quiz-answer">目標は「インデックスが効く/効かない」の境界を探すことです。order_date の範囲を広げながら EXPLAIN ANALYZE を繰り返し、Bitmap → Seq Scan に切り替わるポイントを確認します。
        <div class="code-block">
          <pre><code class="language-sql">-- 前準備: 単一列インデックスと統計更新
CREATE INDEX IF NOT EXISTS idx_orders_order_date ON orders(order_date);
ANALYZE orders;

-- 1) 狭い範囲 (7日間) → 高選択率で Index Scan になりやすい
EXPLAIN ANALYZE
SELECT *
FROM orders
WHERE order_date BETWEEN '2023-06-01' AND '2023-06-07';

-- 2) 30日間に拡張 → Bitmap / Index / Seq の境界を探る
EXPLAIN ANALYZE
SELECT *
FROM orders
WHERE order_date BETWEEN '2023-06-01' AND '2023-06-30';

-- 3) 90日間に拡張 → Seq Scan に寄り始めるか確認
EXPLAIN ANALYZE
SELECT *
FROM orders
WHERE order_date BETWEEN '2023-04-01' AND '2023-06-30';

-- 4) 行数割合を確認（例: 全体 1,500,000 行のうち何行ヒットするか）
SELECT COUNT(*) AS hit_rows,
       round(100.0 * COUNT(*) / (SELECT reltuples::bigint FROM pg_class WHERE relname = 'orders'), 2) AS hit_pct
FROM orders
WHERE order_date BETWEEN '2023-04-01' AND '2023-06-30';

-- 目安: ヒット率が5〜15%を超えると Seq Scan が選ばれやすい。
-- 実データと統計更新の状態で境界が変わるので、自分の環境で計測すること。
</code></pre>
        </div>
        <p>実行結果例（正常動作）</p>
        <div class="result-block">
          <pre><code class="language-sql">CREATE INDEX
ANALYZE</code></pre>
        </div>
        <p><strong>範囲1: 2023-06-01〜2023-06-07 (7日間)</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">                                                               QUERY PLAN                                

----------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on orders  (cost=358.22..13247.19 rows=25931 width=33) (actual time=2.412..15.313 rows=28674 loops=1)
   Recheck Cond: ((order_date >= '2023-06-01'::date) AND (order_date <= '2023-06-07'::date))
   Heap Blocks: exact=11296
   ->  Bitmap Index Scan on idx_orders_order_date  (cost=0.00..351.74 rows=25931 width=0) (actual time=1.223..1.223 rows=28674 loops=1)
         Index Cond: ((order_date >= '2023-06-01'::date) AND (order_date <= '2023-06-07'::date))
 Planning Time: 1.449 ms
 Execution Time: 16.465 ms
(7 行)</code></pre>
        </div>
        <p><strong>範囲2: 2023-06-01〜2023-06-30 (30日間)</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">                                                                QUERY PLAN                               

--------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on orders  (cost=1653.18..15963.07 rows=120659 width=33) (actual time=6.210..54.998 rows=122999 loops=1)
   Recheck Cond: ((order_date >= '2023-06-01'::date) AND (order_date <= '2023-06-30'::date))
   Heap Blocks: exact=12499
   ->  Bitmap Index Scan on idx_orders_order_date  (cost=0.00..1623.02 rows=120659 width=0) (actual time=4.540..4.541 rows=122999 loops=1)
         Index Cond: ((order_date >= '2023-06-01'::date) AND (order_date <= '2023-06-30'::date))
 Planning Time: 0.095 ms
 Execution Time: 58.217 ms
(7 行)</code></pre>
        </div>
        <p><strong>範囲3: 2023-04-01〜2023-06-30 (90日間)</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">                                                                 QUERY PLAN                              

----------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on orders  (cost=5067.54..23115.52 rows=369865 width=33) (actual time=33.257..113.888 rows=373119 loops=1)
   Recheck Cond: ((order_date >= '2023-04-01'::date) AND (order_date <= '2023-06-30'::date))
   Heap Blocks: exact=12500
   ->  Bitmap Index Scan on idx_orders_order_date  (cost=0.00..4975.08 rows=369865 width=0) (actual time=21.761..21.762 rows=373119 loops=1)
         Index Cond: ((order_date >= '2023-04-01'::date) AND (order_date <= '2023-06-30'::date))
 Planning Time: 0.135 ms
 Execution Time: 126.810 ms
(7 行)</code></pre>
        </div>
        <p><strong>ヒット件数と割合 (90日間)</strong></p>
        <div class="result-block">
          <pre><code class="language-sql"> hit_rows | hit_pct
----------+---------
   373119 |   24.87
(1 行)</code></pre>
        </div>
        <p>範囲を広げるとヒット率が約25%となり、Bitmap Heap Scanで処理されています。Seq Scanに切り替わる境界を探るステップとして正常な出力です。</p>
      </div>      
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. カーディナリティとは何か?</div>
      <div class="quiz-answer">列の値の種類の多さを示す指標。例えばstatus列がcompleted/cancelled/pendingの3値しかない場合、カーディナリティは低い。主キーのように全行で異なる値を持つ列はカーディナリティが高くなります。</div>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. PostgreSQLがSeq ScanとIndex Scanを切り替える判断基準は?</div>
      <div class="quiz-answer">主に選択率（ヒット件数/全件数）に基づきます。一般的に全体の5～15%以上のデータにヒットする場合、インデックスを使うよりもSeq Scanの方がコストが低いと判断されます。統計情報を元に実行計画オプティマイザが自動で決定します。</div>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q3. インデックスがあるのに使われない場合の対処法は?</div>
      <div class="quiz-answer">①統計情報を更新（ANALYZE）、②WHERE句の条件を見直し選択率を下げる、③部分インデックスを検討、④クエリヒントでIndex Scanを強制（本番非推奨）などがあります。ただし多くの場合、PostgreSQLの判断は正しいため、無理にインデックスを使わせる必要はありません。</div>
      <span class="important"><strong>ポイント:</strong> インデックスを「使わせる」ことより、「PostgreSQLが正しく判断できる環境を作る」ことが大切です。</span>    </section>

    <section class="fes-section" id="section-3-5">
      <h3>第3.5部 実践編: 部分インデックスと条件付きインデックス </h3>
      <p>インデックスのサイズを削減し、更新性能を維持しながら検索を高速化する「部分インデックス」を学びます。</p>
      
      <h4>部分インデックスとは</h4>
      <p>テーブルの一部の行だけにインデックスを作成する手法です。例えば「未完了の注文」だけを頻繁に検索する場合、完了済みの大量データにインデックスを貼る必要はありません。</p>
      
      <h4>実験4: 部分インデックスの効果</h4>
      <div class="code-block">
        <pre><code class="language-sql">-- 通常のインデックス（全行対象）
CREATE INDEX idx_orders_status_full ON orders(status);

-- 部分インデックス（pendingのみ対象）
CREATE INDEX idx_orders_pending ON orders(order_date)
  WHERE status = 'pending';

-- 部分インデックスを使うクエリ
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE status = 'pending'
  AND order_date >= '2023-06-01'
ORDER BY order_date;
</code></pre>
      </div>

      <h4>実行結果例</h4>
      <p><strong>通常のインデックスを使った場合（idx_orders_status_full）</strong></p>
      <div class="result-block">
        <pre><code class="language-sql">                                                                   QUERY PLAN                            

------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12151.53..12171.13 rows=7839 width=33) (actual time=9.879..10.517 rows=7924 loops=1)        
   Sort Key: order_date
   Sort Method: quicksort  Memory: 613kB
   ->  Index Scan using idx_orders_status_full on orders  (cost=0.43..11644.49 rows=7839 width=33) (actual time=0.055..9.093 rows=7924 loops=1)
         Index Cond: (status = 'pending'::text)
         Filter: (order_date >= '2023-06-01'::date)
         Rows Removed by Filter: 5482
 Planning Time: 2.837 ms
 Execution Time: 11.254 ms
(9 行)</code></pre>
      </div>

      <h4>結果の解釈</h4>
      <ul>
        <li><strong>実行計画の流れ:</strong> Index Scan → Filter → Sort の3段階で処理</li>
        <li><strong>Index Scan using idx_orders_status_full:</strong> status='pending'で候補を絞るため通常インデックスを使用</li>
        <li><strong>Filter (order_date >= '2023-06-01'):</strong> インデックスに含まれない条件なので、取得後にフィルタリング（5482行削除）</li>
        <li><strong>Sort:</strong> order_dateでソートが必要（インデックスにorder_dateが含まれていないため）</li>
        <li><strong>実行時間: 11.254 ms:</strong> 数千行の処理とソートを含めて約11msと合理的</li>
      </ul>
      <span class="important"><strong>ポイント:</strong> 部分インデックスの効果を最大化するには、WHERE句の条件だけでなく、SELECTやORDER BYで使う列も含める必要があります。</span>

      <h4>部分インデックスの利点</h4>
      <ul>
        <li><strong>サイズ削減:</strong> インデックスが小さくなり、メモリ効率が向上</li>
        <li><strong>更新性能:</strong> インデックス更新の対象行が減り、INSERT/UPDATEが高速化</li>
        <li><strong>キャッシュ効率:</strong> 必要なデータだけがメモリに載るため、ヒット率向上</li>
        <li><strong>選択率改善:</strong> 特定条件に特化することで、常に効率的に使われる</li>
      </ul>
      
      <h4>実践例: 特定ステータスの注文だけをインデックス</h4>
      <p>部分インデックスの典型的なユースケースは、特定のステータスのレコードだけをインデックス対象にすることです。以下は、完了していない注文（pendingまたはcancelled）だけをインデックスする例です。</p>
      <div class="code-block">
        <pre><code class="language-sql">-- 前回作成したインデックスを削除（複数回実行可能にするため）
DROP INDEX IF EXISTS idx_incomplete_orders;

-- 完了していない注文だけにインデックス
CREATE INDEX idx_incomplete_orders ON orders(user_id)
  WHERE status IN ('pending', 'cancelled');

-- インデックスが効いているか確認
EXPLAIN ANALYZE
SELECT COUNT(*) FROM orders
WHERE status IN ('pending', 'cancelled');

-- 特定ユーザーの未完了注文を検索
SELECT * FROM orders
WHERE user_id = 1000
  AND status IN ('pending', 'cancelled');
</code></pre>
      </div>

      <h4>実行結果例</h4>
      <p><strong>EXPLAIN ANALYZE（COUNT(*)の結果）</strong></p>
      <div class="result-block">
        <pre><code class="language-sql">                                                                      QUERY PLAN                         

-------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate  (cost=3424.85..3424.86 rows=1 width=8) (actual time=12.370..12.371 rows=1 loops=1)
   ->  Index Only Scan using idx_orders_status_full on orders  (cost=0.43..3057.85 rows=146800 width=0) (actual time=0.039..7.489 rows=150600 loops=1)
         Index Cond: (status = ANY ('{pending,cancelled}'::text[]))
         Heap Fetches: 0
 Planning Time: 0.420 ms
 Execution Time: 12.399 ms
(6 行)</code></pre>
      </div>

      <p><strong>SELECT（特定ユーザーの検索結果）</strong></p>
      <div class="result-block">
        <pre><code class="language-sql"> order_id | user_id | order_date | status | total_amount
----------+---------+------------+--------+--------------
(0 行)
</code></pre>
      </div>

      <h4>結果の解釈</h4>
      <ul>
        <li><strong>DROP INDEX IF EXISTS:</strong> 前回作成したインデックスを削除。複数回実行する場合はこのコマンドで既存インデックスをクリア</li>
        <li><strong>CREATE INDEX成功:</strong> 部分インデックスが正常に作成された</li>
        <li><strong>Index Only Scan using idx_orders_status_full:</strong> インデックスだけでクエリが完結している最適な実行計画</li>
        <li><strong>Heap Fetches: 0:</strong> テーブル本体へのアクセスが0回。完全にインデックスだけで処理できている証拠</li>
        <li><strong>rows=150600:</strong> 全体1,500,000件のうち、pending/cancelledは150,600件（約10%）</li>
        <li><strong>Execution Time: 12.399 ms:</strong> 150,000件以上をスキャンしながら集計でも約12ms</li>
        <li><strong>SELECT結果が0行:</strong> user_id = 1000では完了していない注文が存在しない（これは正常）</li>
        <li><strong>インデックスの効果:</strong> 90%のcompletedレコードを除外し、インデックスサイズを約1/10に削減</li>
      </ul>
      <span class="important"><strong>ポイント:</strong> 部分インデックスは「データが存在しない場合も含め」スキャン範囲を限定する。マッチしなくても、検索範囲が限定されているため効率的です。</span>
      
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. 部分インデックスが有効なユースケースは?</div>
      <div class="quiz-answer">①特定ステータスのレコードだけを頻繁に検索する場合、②論理削除（ソフトデリート）で有効なレコードだけを扱う場合、③直近データだけを検索する場合（例: 過去1年分のみ）、④NULLではない行だけを対象にする場合などです。全体の10～20%以下のデータに絞れる場合に特に効果的です。</div>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. 部分インデックス使用時の注意点は?</div>
      <div class="quiz-answer">クエリのWHERE句にインデックス作成時と同じ条件を含める必要があります。例えば WHERE status = 'pending' で部分インデックスを作った場合、クエリにもこの条件が必要です。条件が一致しないとインデックスは使われません。</div>
      
      <p><strong>SQLドリル:</strong> 以下のシナリオに最適な部分インデックスを設計してみよう。</p>
      <p><strong>シナリオ: 未完了注文だけを頻繁に検索・分析する</strong></p>
      <div class="quiz-question" onclick="toggleAnswer(this)">SQLドリルの解答例を表示</div>
      <div class="quiz-answer">
      
      <p>完了済み注文（completed）は分析対象外で、pending と cancelled だけを索引対象にしたい場合。全体150万件のうち、未完了は約15万件（10%）に限定されます。</p>
        <div class="code-block">
          <pre><code class="language-sql">-- 解答例: 未完了注文だけに絞った部分インデックス
-- ポイント: 完了済み注文（90%）を除外し、インデックスサイズを1/10に削減
CREATE INDEX idx_orders_incomplete ON orders(order_date DESC, user_id)
  WHERE status IN ('pending', 'cancelled');

-- 活用例1a: 未完了注文を日付順に取得
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE status IN ('pending', 'cancelled')
  AND order_date >= '2023-06-01'
ORDER BY order_date DESC;

-- 活用例1b: ユーザー別の未完了件数ランキング
EXPLAIN ANALYZE
SELECT 
  user_id,
  COUNT(*) as incomplete_count
FROM orders
WHERE status IN ('pending', 'cancelled')
GROUP BY user_id
ORDER BY incomplete_count DESC
LIMIT 20;

-- インデックスサイズの比較
SELECT 
  indexrelname,
  pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_stat_user_indexes
WHERE relname = 'orders'
ORDER BY pg_relation_size(indexrelid) DESC;
</code></pre>
        </div>
        
        <p><strong>実行結果例（正常動作）</strong></p>
        <p><strong>活用例1b: ユーザー別の未完了件数</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">                                                                            QUERY PLAN                   

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=7190.23..7190.28 rows=20 width=12) (actual time=48.021..48.025 rows=20 loops=1)
   ->  Sort  (cost=7190.23..7383.27 rows=77215 width=12) (actual time=48.018..48.020 rows=20 loops=1)    
         Sort Key: (count(*)) DESC
         Sort Method: top-N heapsort  Memory: 26kB
         ->  GroupAggregate  (cost=0.42..5135.57 rows=77215 width=12) (actual time=1.326..42.351 rows=77745 loops=1)
               Group Key: user_id
               ->  Index Only Scan using idx_incomplete_orders on orders  (cost=0.42..3610.67 rows=150550 width=4) (actual time=1.317..26.261 rows=150600 loops=1)
                     Heap Fetches: 0
 Planning Time: 0.303 ms
 Execution Time: 48.066 ms
(10 行)</code></pre>
        </div>
        
        <p><strong>インデックスサイズ比較</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">      indexrelname      |  size
------------------------+---------
 orders_pkey            | 32 MB
 idx_orders_user_date   | 32 MB
 idx_orders_status      | 10 MB
 idx_orders_status_full | 10 MB
 idx_orders_order_date  | 10 MB
 idx_orders_incomplete  | 3328 kB
 idx_incomplete_orders  | 2704 kB
 idx_orders_pending     | 112 kB
(8 行)</code></pre>
        </div>
        
        <p><strong>結果の解釈</strong></p>
        <ul>
          <li><strong>Index Only Scan で 150,600 行を処理:</strong> Heap Fetches: 0 は、テーブル本体に一度もアクセスせずインデックスだけで完結したことを示す。完璧な実行計画</li>
          <li><strong>実行時間 48.066 ms:</strong> 150,000 件以上のグループ化＆ソートにしては高速。通常インデックスだと処理行数が 150万件になるため大幅に遅い</li>
          <li><strong>メモリ効率:</strong> top-N heapsort で 26kB しか使用。ORDER BY DESC LIMIT 20 により、効率的なソート実装</li>
          <li><strong>インデックスサイズの劇的な削減:</strong></li>
          <ul>
            <li><strong>通常インデックス（idx_orders_status）:</strong> 10 MB（全 150 万件対象）</li>
            <li><strong>部分インデックス（idx_incomplete_orders）:</strong> 2704 kB（150,600 件のみ対象）</li>
            <li><strong>削減率:</strong> 73% 削減。ストレージとメモリ効率が大幅に向上</li>
          </ul>
          <li><strong>スケーラビリティ:</strong> データが増えても、部分インデックスサイズの増加は「未完了件数の増加」だけ。completed レコードの増加は無関係</li>
        </ul>
        
        <p><strong>設計のポイント</strong></p>
        <ul>
          <li><strong>IMMUTABLE な条件のみ使用:</strong> 部分インデックスの WHERE 句には <strong>固定値の比較</strong>（=, IN, >, <）のみ使用可能。CURRENT_DATE、NOW() などの volatile 関数は使えません</li>
          <li><strong>実用的な部分インデックス:</strong> status = 'pending'、is_deleted = false など、比較的固定値で絞る場合に効果的</li>
          <li><strong>複合列の活用:</strong> (order_date DESC, user_id) で検索とソートの両方に対応</li>
          <li><strong>更新効率:</strong> completed データへの更新はインデックスを触らないため、書き込み性能向上</li>
          <li><strong>WHERE句の必須条件:</strong> クエリに「status IN ('pending', 'cancelled')」を含める必要があります</li>
        </ul>
        </div>
    </section>

    <section class="fes-section" id="section-4">
      <h3>第4部 発展編: 複合インデックスと最左プレフィクス </h3>
      <p>複数列の B-Tree では「左から順に並ぶ」ため、列の並び順が性能を左右します。</p>
      <h4>実験3: 複合インデックスの順序</h4>
      <h4>実行SQL</h4>
      <div class="code-block">
        <pre><code class="language-sql">CREATE INDEX idx_orders_user_date ON orders(user_id, order_date);
 
    -- 効く (user_id で絞る)
    EXPLAIN ANALYZE
    SELECT * FROM orders WHERE user_id = 100 AND order_date >= '2023-06-01';
 
    -- 効きにくい (order_date 単独)
    EXPLAIN ANALYZE
    SELECT * FROM orders WHERE order_date >= '2023-06-01';
 
    -- 爆速 (両方使う)
    EXPLAIN ANALYZE
    SELECT * FROM orders WHERE user_id = 100 AND order_date BETWEEN '2023-06-01' AND '2023-06-30';
    </code></pre>
      </div>

      <h4>実行結果例</h4>
      <p><strong>ケース1: user_id で絞る（最左プレフィクス条件を満たす）</strong></p>
      <div class="result-block">
        <pre><code class="language-sql">                                                          QUERY PLAN                                     

------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on orders  (cost=4.52..39.93 rows=9 width=33) (actual time=0.055..0.080 rows=11 loops=1)
   Recheck Cond: ((user_id = 100) AND (order_date >= '2023-06-01'::date))
   Heap Blocks: exact=11
   ->  Bitmap Index Scan on idx_orders_user_date  (cost=0.00..4.52 rows=9 width=0) (actual time=0.045..0.046 rows=11 loops=1)
         Index Cond: ((user_id = 100) AND (order_date >= '2023-06-01'::date))
 Planning Time: 0.636 ms
 Execution Time: 0.120 ms
(7 行)</code></pre>
      </div>

      <p><strong>ケース2: order_date 単独（最左プレフィクス条件を満たさない）</strong></p>
      <div class="result-block">
        <pre><code class="language-sql">                                                   QUERY PLAN                                            

----------------------------------------------------------------------------------------------------------------
 Seq Scan on orders  (cost=0.00..31250.00 rows=884067 width=33) (actual time=0.010..84.502 rows=881893 loops=1)
   Filter: (order_date >= '2023-06-01'::date)
   Rows Removed by Filter: 618107
 Planning Time: 0.053 ms
 Execution Time: 104.916 ms
(5 行)</code></pre>
      </div>

      <p><strong>ケース3: 両方使う（最適な条件）</strong></p>
      <div class="result-block">
        <pre><code class="language-sql">                                                          QUERY PLAN                                     

------------------------------------------------------------------------------------------------------------------------------
 Index Scan using idx_orders_user_date on orders  (cost=0.43..8.45 rows=1 width=33) (actual time=0.010..0.011 rows=1 loops=1)
   Index Cond: ((user_id = 100) AND (order_date >= '2023-06-01'::date) AND (order_date <= '2023-06-30'::date))
 Planning Time: 0.134 ms
 Execution Time: 0.029 ms
(4 行)</code></pre>
      </div>

      <h4>結果の解釈</h4>
      <ul>
        <li><strong>ケース1 (Bitmap Scan, 0.120 ms):</strong> user_idで候補を絞ってからorder_dateで追絞り。インデックスが効いている</li>
        <li><strong>ケース2 (Seq Scan, 104.916 ms):</strong> order_date単独ではインデックスが効かずSeq Scan選択。実行時間は約870倍遅い</li>
        <li><strong>ケース3 (Index Scan, 0.029 ms):</strong> 両方の条件で完全に最適化。ケース2比で約3,600倍高速化</li>
        <li><strong>最左プレフィクスの威力:</strong> 複合インデックス(user_id, order_date)は左端のuser_idでソートされているため、order_date単独では効きにくい</li>
        <li><strong>コスト差：</strong> ケース1(cost=4.52) vs ケース2(cost=31250.00)で明確な差が出ている</li>
      </ul>
      <span class="important"><strong>ポイント:</strong> 複合インデックスの列順は極めて重要。最左プレフィクス条件を満たさないと、インデックスが使われず全件スキャンになる危険性があります。</span>
      <p><strong>テキスト図解 (B-Tree の並びイメージ):</strong></p>
      <div class="diagram-block">
        <pre><code>user_id | order_date | ...
------- | ---------- | ----
100     | 2023-06-01
100     | 2023-06-02
100     | 2023-06-03
101     | 2023-01-10
101     | 2023-01-11
...</code></pre>
      </div>
      <p>左端列 (user_id) でまずソートされ、その中で order_date が並ぶため、左側の列を使わない条件では効きにくくなります。</p>
      
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. 複合インデックス (A, B) がある場合、WHERE B = ? だけの条件でインデックスは効くか?</div>
      <div class="quiz-answer">基本的に効きません（または効率が悪い）。B-Treeは左端列(A)でソートされているため、Aを指定せずBだけで検索すると木構造を効率的に辿れません。この場合は別途 (B) のインデックスを作成するか、WHERE句にAの条件も加える必要があります。</div>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. 複合インデックスの列順をどう決めるべきか?</div>
      <div class="quiz-answer">一般的には①カーディナリティが高い列を左に、②WHERE句で頻繁に使われる列を左に、③等価条件(=)の列を範囲条件(>, BETWEEN)の列より左に配置します。実際のクエリパターンを分析し、最も頻繁に実行されるクエリに最適化するのが基本です。</div>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q3. (user_id, order_date) と (order_date, user_id) の違いは?</div>
      <div class="quiz-answer">根本的に異なるインデックスです。前者はuser_id→order_dateの順でソート、後者はorder_date→user_idの順でソート。WHERE user_id = X には前者が、WHERE order_date = Y には後者が効きます。クエリパターンに応じて適切な順序を選ぶ必要があります。</div>
      
      <p><strong>SQLドリル:</strong> 以下の3つのクエリパターンに最も効率的な複合インデックスを1つだけ設計してみよう。</p>
      
      <p><strong>クエリパターン（頻度順）:</strong></p>
      <ol>
        <li>特定ユーザーの直近注文（頻度: 高）</li>
        <li>特定ステータスの注文を日付順に取得（頻度: 中）</li>
        <li>特定ユーザーの特定ステータス注文（頻度: 低）</li>
      </ol>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">SQLドリルの解答例を表示</div>
      <div class="quiz-answer">
        <div class="code-block">
          <pre><code class="language-sql">-- 最も頻度の高いパターン1に最適化したインデックス
CREATE INDEX idx_orders_user_date_status ON orders(user_id, order_date DESC, status);

-- パターン1: 特定ユーザーの直近注文（最優先）
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE user_id = 5000
ORDER BY order_date DESC
LIMIT 10;

-- パターン2: 特定ステータスの注文を日付順
-- 注意: このパターンではインデックスが効きにくい（user_idが左端のため）
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE status = 'pending'
ORDER BY order_date DESC
LIMIT 20;

-- パターン3: 特定ユーザーの特定ステータス
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE user_id = 5000
  AND status = 'completed'
ORDER BY order_date DESC;

-- 代替案: パターン2にも対応するには別のインデックスが必要
-- CREATE INDEX idx_orders_status_date ON orders(status, order_date DESC);
</code></pre>
        </div>
        
        <p><strong>実行結果例（正常動作）</strong></p>
        
        <p><strong>パターン1: 特定ユーザーの直近注文（最優先）</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">CREATE INDEX

                                                                  QUERY PLAN                             

----------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.43..43.10 rows=10 width=33) (actual time=0.166..0.195 rows=10 loops=1)
   ->  Index Scan using idx_orders_user_date_status on orders  (cost=0.43..68.70 rows=16 width=33) (actual time=0.164..0.192 rows=10 loops=1)
         Index Cond: (user_id = 5000)
 Planning Time: 5.038 ms
 Execution Time: 0.801 ms
(5 行)</code></pre>
        </div>
        
        <p><strong>パターン2: 特定ステータスの注文を日付順</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">                                                                     QUERY PLAN                          

----------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=0.29..52.15 rows=20 width=33) (actual time=0.009..0.072 rows=20 loops=1)
   ->  Index Scan Backward using idx_orders_pending on orders  (cost=0.29..35916.01 rows=13850 width=33) (actual time=0.009..0.070 rows=20 loops=1)
 Planning Time: 0.158 ms
 Execution Time: 0.081 ms
(4 行)</code></pre>
        </div>
        
        <p><strong>パターン3: 特定ユーザーの特定ステータス注文</strong></p>
        <div class="result-block">
          <pre><code class="language-sql">                                                                 QUERY PLAN                              

--------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=59.66..59.70 rows=14 width=33) (actual time=0.067..0.069 rows=19 loops=1)
   Sort Key: order_date DESC
   Sort Method: quicksort  Memory: 26kB
   ->  Bitmap Heap Scan on orders  (cost=4.59..59.40 rows=14 width=33) (actual time=0.017..0.061 rows=19 loops=1)
         Recheck Cond: ((user_id = 5000) AND (status = 'completed'::text))
         Heap Blocks: exact=19
         ->  Bitmap Index Scan on idx_orders_user_date_status  (cost=0.00..4.59 rows=14 width=0) (actual time=0.011..0.012 rows=19 loops=1)
               Index Cond: ((user_id = 5000) AND (status = 'completed'::text))
 Planning Time: 0.074 ms
 Execution Time: 0.081 ms
(10 行)</code></pre>
        </div>
        
        <p><strong>結果の解釈</strong></p>
        <ul>
          <li><strong>パターン1 (0.801ms):</strong> Index Scan で user_id で絞った後、order_date DESC でソート。LIMIT 10 で瞬時に完了。インデックスが完璧に機能</li>
          <li><strong>パターン2 (0.081ms):</strong> 別のインデックス（idx_orders_pending）が使われた。Backward Scan で降順ソートを効率化。超高速</li>
          <li><strong>パターン3 (0.081ms):</strong> Bitmap Heap Scan で user_id と status で絞った後、Sort で order_date DESC にソート。わずかなソート処理だけで高速</li>
          <li><strong>全パターンがミリ秒単位:</strong> インデックス設計が機能している証拠。すべてのクエリが 1ms 以下で完了</li>
        </ul>
        
        <p><strong>設計の考え方</strong></p>
        <ul>
          <li><strong>頻度を優先:</strong> 最も頻繁なパターン1を完全に最適化</li>
          <li><strong>列の順序:</strong> user_id（等価条件）→ order_date（範囲＋ソート）→ status（フィルタ）</li>
          <li><strong>DESC指定:</strong> ORDER BY order_date DESC に対応し、ソート処理を省略</li>
          <li><strong>パターン3も恩恵:</strong> user_id で絞った後、order_date でソート、status でフィルタが効率的</li>
          <li><strong>トレードオフ:</strong> パターン2はこのインデックスでは効きにくい。しかし頻度が低ければ許容。必要に応じて別インデックスを追加</li>
        </ul>
        
        <p><strong>実務的指針</strong></p>
        <ul>
          <li>複数のクエリパターンがある場合、①頻度の高いものを優先、②すべてに対応しようとして過剰にインデックスを作らない</li>
          <li>pg_stat_statements で実際の頻度を計測し、本当に必要なインデックスだけを追加</li>
          <li>パターン2 のような「別の軸でのクエリ」が頻発する場合は、(status, order_date DESC) の追加インデックスも検討</li>
          <li>ただし「すべてのクエリを最適化」より「メインとなるクエリを最優先」する方が実用的</li>
        </ul>
      </div>
    </section>

    <section class="fes-section" id="section-5">
      <h3>第5部 総合演習: スロークエリ・チューニング </h3>
      <p>講師が用意した「遅い検索クエリ」を最適化し、2秒 → 0.05秒未満を目指します。インデックスは1つだけ作成可。</p>
      <h4>遅いクエリ例と改善ミッション</h4>
      <div class="code-block">
        <pre><code class="language-sql">-- 遅い例: ユーザ単位の期間検索 + ソート
EXPLAIN ANALYZE
SELECT order_id, order_date, total_amount, status
FROM orders
WHERE user_id = 4242
  AND order_date BETWEEN '2023-06-01' AND '2023-06-30'
ORDER BY order_date DESC;

-- ミッション: 最適な CREATE INDEX を1本だけ設計せよ
-- 例解 (一案):
-- CREATE INDEX idx_orders_user_date_only ON orders(user_id, order_date DESC) INCLUDE (total_amount);
</code></pre>
      </div>
      <p>索引候補を試し、EXPLAIN ANALYZE でコスト・実行時間・使用ノード (Index Scan / Index Only Scan / Bitmap) を確認して改善します。</p>

      <h4>実行結果例（抜粋）</h4>
      <div class="result-block">
        <pre><code class="language-sql">                                                      QUERY PLAN

Index Cond: ((user_id = 4242) AND (order_date >= '2023-06-01'::date) AND (order_date <= '2023-06-30'::date))
Planning Time: 0.739 ms
Execution Time: 0.240 ms
(4 行)
</code></pre>
      </div>

      <h4>結果の解釈</h4>
      <ul>
        <li><strong>Index Scan選択:</strong> 複合インデックスが有効に使われ、user_idの等価条件とorder_dateの範囲条件で高速に抽出されています</li>
        <li><strong>低レイテンシ:</strong> Execution Timeが0.240ms、抽出行数5件という小規模結果に対して期待通りの高速動作です</li>
        <li><strong>ソート最適化:</strong> ORDER BY order_date DESCのクエリは、降順で作成した複合インデックスを用意すれば追加ソートを省略できます</li>
        <li><strong>実務的指針:</strong> このパターンでは (user_id, order_date DESC) に加え INCLUDE (total_amount) を検討すると、Index Only Scanでさらなる高速化が期待できます</li>
      </ul>
      
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. なぜ例解のインデックスに DESC を指定しているのか?</div>
      <div class="quiz-answer">クエリが ORDER BY o.order_date DESC でソートしているため。インデックスを降順で作成しておくと、ソート処理をスキップできIndex Only Scanが可能になり、さらに高速化できます。</div>
      <span class="important"><strong>ポイント:</strong> インデックスの列順だけでなく、昇順/降順も性能に大きく影響します。</span>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. INCLUDE句の役割は何か?</div>
      <div class="quiz-answer">インデックスのリーフノードに追加データを含めることで、Index Only Scanを可能にします。total_amountをINCLUDEすることで、テーブル本体にアクセスせずインデックスだけで全データを取得できます(Covering Index)。</div>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q3. Index Scan と Index Only Scan の違いは?</div>
      <div class="quiz-answer">Index Scanはインデックスで行を特定した後、テーブル本体からデータを取得します。Index Only Scanはインデックスだけで全データを取得できるため、テーブルアクセスが不要で高速です。INCLUDEやカバリングインデックスでIndex Only Scanを実現できます。</div>
    </section>

    <section class="fes-section" id="section-6">
      <h3>第6部 運用編: インデックスのメンテナンスとベストプラクティス </h3>
      <p>インデックスは作って終わりではありません。適切な運用とメンテナンスが継続的な性能維持に不可欠です。</p>
      
      <h4>統計情報の更新</h4>
      <p>PostgreSQLは統計情報をもとに最適な実行計画を選びます。データ量が大きく変化した後は、統計情報を更新しましょう。</p>
      <div class="code-block">
        <pre><code class="language-sql">-- 特定テーブルの統計情報を更新
ANALYZE orders;

-- データベース全体の統計情報を更新
ANALYZE;

-- VACUUMと同時実行（不要データ削除 + 統計更新）
VACUUM ANALYZE orders;
</code></pre>
      </div>
      
      <h4>実行結果例</h4>
      <div class="result-block">
        <pre><code class="language-sql">
    ANALYZE
    ANALYZE
    VACUUM
    </code></pre>
      </div>
      <p>psqlでは各コマンドが正常終了すると、そのコマンド名がそのまま表示されます。上記出力は正常な動作です。</p>
      
      <h4>インデックスの再構築</h4>
      <p>長期運用でインデックスが肥大化・断片化した場合、再構築で性能を回復できます。</p>
      <div class="code-block">
        <pre><code class="language-sql">-- インデックスの再構築（ロックあり）
REINDEX INDEX idx_orders_user_date;

-- テーブルの全インデックスを再構築
REINDEX TABLE orders;

-- 並行再構築（ロックなし、PostgreSQL 12+）
CREATE INDEX CONCURRENTLY idx_orders_user_date_new 
  ON orders(user_id, order_date);
DROP INDEX CONCURRENTLY idx_orders_user_date;
ALTER INDEX idx_orders_user_date_new RENAME TO idx_orders_user_date;
</code></pre>
      </div>
      
      <h4>実行結果例</h4>
      <div class="result-block">
        <pre><code class="language-sql">REINDEX
REINDEX
CREATE INDEX
DROP INDEX
ALTER INDEX
</code></pre>
      </div>
      <p>psqlでは各コマンドが正常終了すると、そのコマンド名が表示されます。上記出力は正常な動作です。</p>
      
      <h4>インデックス設計のベストプラクティス</h4>
      <ul>
        <li><strong>必要なものだけ作る:</strong> インデックスは万能ではない。更新コストとのバランスを考慮</li>
        <li><strong>実測で確認:</strong> EXPLAIN ANALYZEで効果を確認してから本番適用</li>
        <li><strong>複合インデックスを活用:</strong> 複数の単一列インデックスより、1つの複合インデックスの方が効率的な場合が多い</li>
        <li><strong>カバリングインデックス:</strong> INCLUDEを使ってIndex Only Scanを狙う</li>
        <li><strong>部分インデックス:</strong> 特定条件に絞ってサイズとコストを削減</li>
        <li><strong>定期メンテナンス:</strong> VACUUMとANALYZEを定期実行</li>
        <li><strong>監視:</strong> pg_stat_user_indexesで未使用インデックスを特定し削除</li>
      </ul>
      
      <h4>未使用インデックスの検出</h4>
      <div class="code-block">
        <pre><code class="language-sql">-- 使用されていないインデックスを検出
SELECT schemaname,
       relname AS tablename,
       indexrelname AS indexname,
       idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0
  AND indexrelname NOT LIKE '%_pkey'
ORDER BY pg_relation_size(indexrelid) DESC;

-- インデックスのサイズ確認
SELECT indexrelname, pg_size_pretty(pg_relation_size(indexrelid))
FROM pg_stat_user_indexes
ORDER BY pg_relation_size(indexrelid) DESC;
</code></pre>
      </div>

      <h4>実行結果例</h4>
      <div class="result-block">
        <pre><code class="language-sql"> schemaname | tablename |      indexname       | idx_scan 
------------+-----------+----------------------+----------
 public     | orders    | idx_orders_user_date |        0
 public     | orders    | idx_orders_pending   |        0
 public     | y_items   | y_items_name_key     |        0
 public     | y_jobs    | y_jobs_name_key      |        0
 public     | x_jobs    | x_jobs_name_key      |        0
 public     | x_guilds  | x_guilds_name_key    |        0
 public     | x_items   | x_items_name_key     |        0
(7 行)
</code></pre>
      </div>
      <div class="result-block">
        <pre><code class="language-sql">      indexrelname       | pg_size_pretty
-------------------------+----------------
 orders_pkey             | 32 MB
 idx_orders_user_date    | 32 MB
 idx_orders_status       | 10 MB
 idx_orders_status_full  | 10 MB
 idx_incomplete_orders   | 2704 kB
 idx_orders_pending      | 112 kB
 y_items_pkey            | 16 kB
 s_users_pkey            | 16 kB
 s_characters_pkey       | 16 kB
 y_items_name_key        | 16 kB
 y_jobs_pkey             | 16 kB
 y_jobs_name_key         | 16 kB
 y_characters_pkey       | 16 kB
 y_character_items_pkey  | 16 kB
 x_jobs_name_key         | 8192 bytes
 x_jobs_pkey             | 8192 bytes
 x_items_name_key        | 8192 bytes
 x_items_pkey            | 8192 bytes
 x_guilds_name_key       | 8192 bytes
 x_guild_characters_pkey | 8192 bytes
 x_character_items_pkey  | 8192 bytes
 x_gold_transfers_pkey   | 8192 bytes
 x_guilds_pkey           | 8192 bytes
 x_characters_pkey       | 8192 bytes
(24 行)
</code></pre>
      </div>

      <h4>結果の解釈</h4>
      <ul>
        <li><strong>未使用候補:</strong> idx_scan=0は統計収集以降で「インデックスが参照されていない」ことを示します。新規作成直後や稼働が少ない期間では正常です</li>
        <li><strong>除外対象:</strong> *_pkeyは主キーであり、削除対象にはしません。業務上必須です</li>
        <li><strong>サイズ観察:</strong> orders_pkey/idx_orders_user_dateが32MBと大きく、データ量に応じた妥当なサイズ感です。小さなテーブルのインデックスは数KB〜数十KBが自然です</li>
        <li><strong>次アクション:</strong> 実運用の典型クエリでの使用状況を一定期間観測し、継続してidx_scan=0かつサイズが大きいものがあれば削除や設計見直しを検討します</li>
      </ul>

      <h4>補足: カラム名の注意</h4>
      <ul>
        <li><strong>relname:</strong> テーブル名（ビュー内の正式カラム）</li>
        <li><strong>indexrelname:</strong> インデックス名（ビュー内の正式カラム）</li>
        <li><strong>alias利用:</strong> 表示上の分かりやすさのため、relnameをtablename、indexrelnameをindexnameとしてエイリアスしています</li>
      </ul>
      
      <h4>よくある落とし穴</h4>
      <ul>
        <li><strong>関数適用でインデックスが効かない:</strong> WHERE LOWER(email) = 'user@example.com' → 関数インデックスが必要</li>
        <li><strong>暗黙の型変換:</strong> WHERE user_id = '123' （文字列と数値） → インデックスが効かない場合あり</li>
        <li><strong>OR条件:</strong> WHERE a = 1 OR b = 2 → 両方の列にインデックスが必要</li>
        <li><strong>LIKE前方一致以外:</strong> WHERE name LIKE '%Smith' → インデックス効かず（前方一致のみ有効）</li>
        <li><strong>統計情報の古さ:</strong> 大量INSERT後にANALYZE忘れ → 誤った実行計画</li>
      </ul>
      
      <h4>定着確認</h4>
      <div class="quiz-question" onclick="toggleAnswer(this)">Q1. ANALYZEコマンドの役割は?</div>
      <div class="quiz-answer">テーブルの統計情報を収集・更新するコマンド。データ分布、行数、カーディナリティなどを分析し、クエリオプティマイザが最適な実行計画を選べるようにします。大量のINSERT/DELETE後や定期的に実行することが推奨されます。</div>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q2. なぜインデックスを作りすぎると問題なのか?</div>
      <div class="quiz-answer">①INSERT/UPDATE/DELETE時にすべてのインデックスを更新する必要があり、書き込み性能が低下、②ストレージ容量を消費、③メモリ（shared_buffers）を圧迫、④VACUUMやANALYZEの時間が増加、⑤未使用インデックスの管理コストが発生します。実測で効果があるものだけを維持すべきです。</div>
      
      <div class="quiz-question" onclick="toggleAnswer(this)">Q3. 本番環境でインデックスを安全に追加する方法は?</div>
      <div class="quiz-answer">CREATE INDEX CONCURRENTLY を使います。通常のCREATE INDEXはテーブルをロックしますが、CONCURRENTLYオプションを付けると書き込みをブロックせずにインデックスを作成できます。ただし通常より時間がかかり、ディスク容量も一時的に多く消費します。</div>
      <span class="warning"><strong>本番環境への注意:</strong> 本番環境でのインデックス作成は必ずCONCURRENTLYオプションを使用し、テーブルロックを避けましょう。</span>
    </section>

    <section class="fes-section" id="section-summary">
      <h3>まとめと次のステップ</h3>
      <p>このガイドで学んだインデックス設計の基礎を、実際のプロジェクトで活用してみましょう。</p>
      
      <h4>習得したスキル</h4>
      <ul>
        <li>EXPLAIN ANALYZEを使った実行計画の読み方</li>
        <li>B-Treeインデックスの仕組みと計算量の理解</li>
        <li>カーディナリティと選択率がインデックス利用に与える影響</li>
        <li>複合インデックスの列順の重要性（最左プレフィクス）</li>
        <li>部分インデックスによるサイズとコストの最適化</li>
        <li>Index Only Scanとカバリングインデックスの設計</li>
        <li>インデックスの運用とメンテナンス手法</li>
      </ul>
      
      <h4>さらなる学習のために</h4>
      <ul>
        <li><strong>公式ドキュメント:</strong> <a href="https://www.postgresql.org/docs/current/indexes.html" target="_blank">PostgreSQL Indexes</a></li>
        <li><strong>GINインデックス:</strong> 全文検索やJSON検索に特化したインデックスタイプ</li>
        <li><strong>GiSTインデックス:</strong> 地理データや範囲検索に適したインデックス</li>
        <li><strong>BRINインデックス:</strong> 超大規模テーブル向けの軽量インデックス</li>
        <li><strong>パーティショニング:</strong> テーブル分割と組み合わせた高度な設計</li>
        <li><strong>並列クエリ:</strong> PostgreSQLの並列処理機能との組み合わせ</li>
      </ul>
      
      <p><strong>実践課題:</strong> 自分のプロジェクトで最も遅いクエリを特定し、このガイドで学んだ技法を使って最適化してみましょう。EXPLAIN ANALYZEで効果を測定し、改善前後の実行時間を比較してください。</p>
    </section>

    <div style="margin-top: 40px; text-align: center;">
      <a href="index.html" class="back-to-home">← トップに戻る</a>
    </div>

    <script>
      // メニューの表示/非表示を切り替える関数
      function toggleMenu() {
        var navigation = document.getElementById("navigation");
        if (navigation.style.display === "block") {
          navigation.style.display = "none";
        } else {
          navigation.style.display = "block";
        }
      }
      
      // 定着確認の答えを表示/非表示
      function toggleAnswer(element) {
        var answer = element.nextElementSibling;
        if (answer && answer.classList.contains('quiz-answer')) {
          answer.classList.toggle('show');
        }
      }
      
      // セクションの折りたたみ機能
      document.addEventListener('DOMContentLoaded', function() {
        const sections = document.querySelectorAll('.fes-section');
        
        sections.forEach(function(section) {
          const heading = section.querySelector('h3');
          if (heading) {
            heading.addEventListener('click', function() {
              section.classList.toggle('collapsed');
            });
          }
        });
      });
      
      // コードブロックにコピーボタンを追加
      document.addEventListener('DOMContentLoaded', function() {
        const codeBlocks = document.querySelectorAll('.code-block');
        
        codeBlocks.forEach(function(block) {
          // コピーボタンを作成
          const button = document.createElement('button');
          button.className = 'copy-button';
          button.textContent = 'Copy';
          
          // コピー機能
          button.addEventListener('click', function() {
            const code = block.querySelector('code');
            const text = code ? code.textContent : block.textContent;
            
            navigator.clipboard.writeText(text).then(function() {
              // コピー成功の視覚的フィードバック
              button.textContent = 'Copied!';
              button.classList.add('copied');
              
              setTimeout(function() {
                button.textContent = 'Copy';
                button.classList.remove('copied');
              }, 2000);
            }).catch(function(err) {
              console.error('コピーに失敗しました:', err);
              button.textContent = 'Error';
              setTimeout(function() {
                button.textContent = 'Copy';
              }, 2000);
            });
          });
          
          block.appendChild(button);
        });
      });
    </script>
  </body>
</html>
